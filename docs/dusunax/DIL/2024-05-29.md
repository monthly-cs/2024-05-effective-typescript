# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-05-29  
> ì‘ì„±ì: dusunax

---

## ì•„ì´í…œ 32: ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ë³´ë‹¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•˜ê¸° Prefer Unions of Interfaces to Interfaces with Unions

### Unions of Interfaces & Interfaces with Unions

- ìœ ë‹ˆì˜¨ íƒ€ì…ì˜ ì†ì„±ì„ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤
- ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ íƒ€ì…

```tsx
// ğŸ¤”
// ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ Unions of Interfaces
interface User {
  id: string;
  name: string;
  contact: string | number;
}

const user1: User = {
  id: "1",
  name: "Alice",
  contact: "123-456-7890",
};
const user2: User = {
  id: "2",
  name: "Bob",
  contact: 9876543210,
};

// ğŸ‘
// ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ Interfaces with Unions
// íƒ€ì… ê°€ë“œë¥¼ í•  ìˆ˜ ìˆë‹¤!
interface Cat {
  type: "cat";
  purrs: boolean;
}

interface Dog {
  type: "dog";
  barks: boolean;
}

type Animal = Cat | Dog;

const animal1: Animal = {
  type: "cat",
  purrs: true,
};

const animal2: Animal = {
  type: "dog",
  barks: true,
};
```

### êµì¬ì˜ ì˜ˆì‹œ

- ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤: ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ê¸° ì‰½ê³ , ì¸í„°í˜ì´ìŠ¤ë¥¼ ë‹¤ë£¨ê¸° ì–´ë µë‹¤
- ë¶„ë¦¬ëœ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìœ ë‹ˆì˜¨: ì˜ëª»ëœ ì¡°í•©ìœ¼ë¡œ ì„ì´ëŠ” ê²ƒì„ ë°©ì§€
  - íƒœê·¸ ì‚¬ìš©!
  - ëŸ°íƒ€ì„ì— íƒ€ì…ì˜ ë²”ìœ„ë¥¼ ì¢í ìˆ˜ ìˆë‹¤ / íƒ€ì… ê°€ë“œ

```tsx
// ğŸ¤”
interface Layer {
  layout: FillLayout | LineLayout | PointLayout;
  paint: FillPaint | LinePaint | PointPaint;
}

// ğŸ‘
interface FillLayer {
  layout: FillLayout;
  paint: FillPaint;
}
interface LineLayer {
  layout: LineLayout;
  paint: LinePaint;
}
interface PointLayer {
  layout: PointLayout;
  paint: PointPaint;
}
type Layer = FillLayer | LineLayer | PointLayer;
```

### íƒœê·¸ëœ ìœ ë‹ˆì˜¨ íŒ¨í„´

- ìœ ìš©í•œ ê²½ìš°
  - ì¸í„°í˜ì´ìŠ¤ì˜ ì†ì„±ì´ ìœ ë‹ˆì˜¨ì¸ ê²½ìš°
  - ì—¬ëŸ¬ ê°œì˜ ì„ íƒì  í•„ë“œê°€ ë™ì‹œì— ê°’ì´ ìˆê±°ë‚˜, ë™ì‹œì— undefinedì¸ ê²½ìš°
- ì¥ì 
  - íƒ€ì…ì˜ ì†ì„±ë“¤ ê°„ ê´€ê³„ë¥¼ ëª¨ë¸ë§
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì½”ë“œì˜ ì •í™•ì„±ì„ ì²´í¬í•˜ëŠ” ë° ë„ì›€ì´ ëœë‹¤

```tsx
// ğŸ‘
interface Person {
  name: string;
  // íƒ€ì…ì— ëŒ€í•œ ì£¼ì„ì€ ì¢‹ì§€ ì•Šë‹¤
  // These will either both be present or not be present
  placeOfBirth?: string; // placeOfBirthì™€ dateOfBirthì˜ ê´€ê³„ê°€ í‘œí˜„ë˜ì§€ ì•Šì•˜ë‹¤
  dateOfBirth?: Date;
}
// ğŸ‘
interface Person {
  name: string;
  birth?: {
    place: string; // placeì™€ dateëŠ” í•¨ê»˜ ì¡´ì¬í•œë‹¤
    date: Date;
  };
}

function eulogize(person: Person) {
  console.log(person.name);
  const { birth } = person;
  if (birth) {
    // Person ë§¤ê°œë³€ìˆ˜ì—ì„œ birthë§Œ ì²´í¬í•˜ë©´ ëœë‹¤
    console.log(`was born on ${birth.date} in ${birth.place}.`);
  }
}
```

### âœ¨ íƒ€ì…ì˜ êµ¬ì¡°ë¥¼ ì† ëŒˆ ìˆ˜ ì—†ëŠ” ì˜ˆì‹œ: API ê²°ê³¼

- ì¸í„°í˜ì´ìŠ¤ë¥¼ ìœ ë‹ˆì˜¨í•œ íƒ€ì…ìœ¼ë¡œ ê´€ê³„ë¥¼ í‘œí˜„í•  ìˆ˜ ìˆë‹¤!~!

```tsx
interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  // í™•ì¥ëœ interface
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth; // interface ìœ ë‹ˆì˜¨

// â—ï¸ ì´ë ‡ê²Œ ì“¸ ìˆ˜ ìˆë‹¤!
function eulogize(person: Person) {
  if ("placeOfBirth" in person) {
    // íƒœê·¸ëœ ìœ ë‹ˆì˜¨ ì²´í¬
    person;
    // ^? (parameter) person: PersonWithBirth
    const { dateOfBirth } = person; // ì •ìƒ
    //     ^? const dateOfBirth: Date
  } else {
    // elseë¼ë©´ Nameì´ë‹¤.
    // placeOfBirthì™€ dateOfBirthì„ ë‘˜ ë‹¤ ê°€ì§€ê³  ìˆì§€ ì•Šì€ ì¸í„°í˜ì´ìŠ¤
  }
}
```

### Things to Remember

- Interfaces with multiple properties that are union types are often a mistake because they obscure the relationships between these properties.
  - ìœ ë‹ˆì˜¨ íƒ€ì…ì˜ ì†ì„±ì„ ì—¬ëŸ¬ ê°œ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ëŠ” ì†ì„± ê°„ì˜ ê´€ê³„ê°€ ë¶„ëª…í•˜ì§€ ì•Šë‹¤.
- Unions of interfaces are more precise and can be understood by TypeScript.
  - ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ë³´ë‹¤, ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ì´ ë” ì •í™•í•˜ê³  íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì´í•´í•˜ê¸° ì¢‹ë‹¤
- Use tagged unions to facilitate control flow analysis. Because they are so well supported, this pattern is ubiquitous in TypeScript code.
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì œì–´ íë¦„ì„ ë¶„ì„í•  ìˆ˜ ìˆë„ë¡, íƒœê·¸ë¥¼ ë„£ëŠ” ê²ƒì„ ê³ ë ¤í•œë‹¤.
  - íƒœê·¸ëœ ìœ ë‹ˆì˜¨ íŒ¨í„´ì€ ìì£¼ ì“°ì„
- Consider whether multiple optional properties could be grouped to more accurately model your data.
  - ì˜µì…”ë„ ì†ì„±ì´ ë§ìœ¼ë©´? ê·¸ë£¹ì„ ì§€ì–´ì„œ ëª¨ë¸ë§í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•˜ê¸°
