# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-05-18  
> ì‘ì„±ì: dusunax

---

## ì•„ì´í…œ 10: ê°ì²´ ë˜í¼ íƒ€ì… í”¼í•˜ê¸° Avoid Object Wrapper Types (String, Number, Boolean, Symbol, BigInt)

- ê¸°ë³¸í˜• ê°’ì˜ 7íƒ€ì…: string, number, boolean, null, undefined, symbol(ES2015), bigint(ìµœì¢… í™•ì • ë‹¨ê³„)
  - immutableì´ë©° ë©”ì„œë“œë¥¼ ê°€ì§€ì§€ ì•ŠëŠ”ë‹¤.
- ë˜í¼ ê°ì²´: String, Number, Boolean, Symbol, BigInt

```tsx
"primitive".charAt(3); // 'm'
```

- JavaScript promptly coerces between primitives and objects.

### stringì˜ propertyì— ì ‘ê·¼í•˜ë ¤ í•  ë•Œ

> The Wrapper Object: https://javascriptrefined.io/the-wrapper-object-400311b29151

- stirngì„ String ê°ì²´ë¡œ wrappingí•˜ê³  (coerce)
- ë˜í¼ ê°ì²´ì—ì„œ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ê³  (new String(string), Stringì˜ ë©”ì„œë“œë¥¼ ìƒì†í•˜ê³ , ì†ì„± ì°¸ì¡°)
- ë˜í•‘í•œ ê°ì²´ë¥¼ ë²„ë¦°ë‹¤. (propertyê°€ resolvedë˜ì—ˆì„ ë•Œ)

### íŠ¹ì§•

```tsx
// ëª½í‚¤íŒ¨ì¹˜? ëŸ°íƒ€ì„ì— í”„ë¡œê·¸ë¨ì˜ ì–´ë–¤ ê¸°ëŠ¥ì„ ìˆ˜ì •í•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²ƒ. jsì—ì„œëŠ” ì£¼ë¡œ í”„ë¡œí† íƒ€ì…
// Don't do this!
const originalCharAt = String.prototype.charAt;
String.prototype.charAt = function (pos) {
  console.log(this, typeof this, pos); // "primitive",  "string",  3
  return originalCharAt.call(this, pos);
};
console.log("primitive".charAt(3));
```

- ê¸°ë³¸í˜•ì— ì†ì„±ì„ ì¶”ê°€í•œë‹¤ë©´? ë˜í¼ ê°ì²´ì™€ í•¨ê»˜ ë²„ë ¤ì§
- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì œê³µí•˜ëŠ” íƒ€ì… ì„ ì–¸ì€ ê¸°ë³¸í˜• íƒ€ì…ì´ë‹¤.
- stringì€ Stringì— í• ë‹¹í•  ìˆ˜ ìˆë‹¤ (Stringì€ stringì— í• ë‹¹í•  ìˆ˜ ì—†ë‹¤)

```tsx
const s: String = "primitive"; // í• ë‹¹ ê°€ëŠ¥í•˜ì§€ë§Œ, ê¸°ë³¸í˜• íƒ€ì…ì„ ì‚¬ìš©í•˜ì
const n: Number = 12;
const b: Boolean = true;

// new í‚¤ì›Œë“œ ì—†ì´ BigIntì™€ Symbolì„ í˜¸ì¶œí•˜ë©´ ê¸°ë³¸í˜•ì„ ìƒì„±í•˜ê¸° ë•Œë¬¸ì— ì‚¬ìš©í•´ë„ ë¨
typeof BigInt(1234); // "bigint"
typeof Symbol("sym"); // "symbol"
```

### Things to Remember

- Avoid TypeScript object wrapper types. Use the primitive types instead: string instead of String, number instead of Number, boolean instead of Boolean, symbol instead of Symbol, and bigint instead of BigInt.
  - ë˜í¼ íƒ€ì…ì´ ì•„ë‹Œ ê¸°ë³¸í˜•(ì›ì‹œí˜•) íƒ€ì… ì‚¬ìš©í•˜ê¸°
- Understand how object wrapper types are used to provide methods on primitive values. Avoid instantiating them or using them directly, with the exception of Symbol and BigInt.
  - ë˜í¼ ê°ì²´ íƒ€ì…ì€ ì›ì‹œí˜•ì— ëŒ€í•œ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì‚¬ìš©ë¨. Symbolì´ë‚˜ BigIntê°€ ì•„ë‹ˆë¼ë©´ ì§ì ‘ ì‚¬ìš©í•˜ì§€ ì•Šê¸°

---

## ì•„ì´í…œ 11: ì‰ì—¬ ì†ì„± ì²´í¬ excess property checkingì˜ í•œê³„ ì¸ì§€í•˜ê¸° Distinguish Excess Property Checking from Type Checking

```tsx
interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}

// A. ì‰ì—¬ ì†ì„± ì²´í¬
const rA: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
  // ~~~~~~~ Object literal may only specify known properties,
  //         and 'elephant' does not exist in type 'Room'
};

// B. êµ¬ì¡°ì  íƒ€ì´í•‘
// objëŠ” Room íƒ€ì…ì˜ ë¶€ë¶„ì§‘í•©ì„ í¬í•¨í•˜ë¯€ë¡œ Roomì— í• ë‹¹ ê°€ëŠ¥í•˜ë©° íƒ€ì… ì²´ì»¤ë„ í†µê³¼
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: "present",
};
const rB: Room = obj; // í†µê³¼ë¨
// ì‰ì—¬ ì†ì„± ì²´í¬ëŠ” í• ë‹¹ ê°€ëŠ¥ ê²€ì‚¬ structural assignability check ì™€ëŠ” ë³„ë„ì˜ ê³¼ì •
```

### ë„“ì€ ë²”ìœ„ì˜ íƒ€ì…, excess property check

```tsx
interface Options {
  title: string;
  darkMode?: boolean;
}
function createWindow(options: Options) {
  if (options.darkMode) {
    setDarkMode();
  }
  // ...
}
createWindow({
  title: "Spider Solitaire",
  darkmode: true,
  // ~~~~~~~ Object literal may only specify known properties,
  //         but 'darkmode' does not exist in type 'Options'.
  //         Did you mean to write 'darkMode'?
});

const o1: Options = document; // documentëŠ” ê°ì²´ ë¦¬í„°ëŸ´ì´ ì•„ë‹ˆë¯€ë¡œ - ì²´í¬ X
const o2: Options = new HTMLAnchorElement(); // ê°ì²´ ë¦¬í„°ëŸ´ì´ ì•„ë‹ˆë¯€ë¡œ - ì‰ì—¬ì†ì„± ì²´í¬ X
const o3: Options = { darkmode: true, title: "Ski Free" }; // ê°ì²´ ë¦¬í„°ëŸ´ì´ë¯€ë¡œ - ì²´í¬ O
// ~~~~~~~~ 'darkmode' does not exist in type 'Options'...

const intermediate = { darkmode: true, title: "Ski Free" }; // right handëŠ” ê°ì²´ ë¦¬í„°ëŸ´ì´ë‹¤
const o3: Options = intermediate; // right handëŠ” ê°ì²´ ë¦¬í„°ëŸ´ì´ ì•„ë‹ˆë‹¤. - ì²´í¬ X

const o = { darkmode: true, title: "MS Hearts" } as Options; // íƒ€ì… ë‹¨ì–¸ì´ë¯€ë¡œ ì²´í¬ X
```

- ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì‚¬ìš©í•´ ì¶”ê°€ì ì¸ ì†ì„± ì˜ˆìƒ

```tsx
interface Options {
  darkMode?: boolean;
  [otherOptions: string]: unknown;
}
const o: Options = { darkmode: true }; // OK
```

- weak type: ì„ íƒì ì¸ ì†ì„±ë§Œ ê°€ì§
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ê°’ íƒ€ì…ê³¼ ì„ ì–¸ íƒ€ì…ì˜ ê³µí†µëœ ì†ì„±ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ì²´í¬ ìˆ˜í–‰
    - ì˜¤íƒ€ ì¡ê¸°, êµ¬ì¡°ì ìœ¼ë¡œ ì—„ê²©í•˜ì§€ ì•ŠìŒ
    - ì„ íƒì  í•„ë“œë¥¼ í¬í•¨í•˜ëŠ” option ê°™ì€ íƒ€ì…ì— ìœ ìš©

```tsx
interface LineChartOptions {
  logscale?: boolean;
  invertedYAxis?: boolean;
  areaChart?: boolean;
}
function setOptions(options: LineChartOptions) {
  /* ... */
}

const opts = { logScale: true };
setOptions(opts);
//         ~~~~ Type '{ logScale: boolean; }' has no properties in common
//              with type 'LineChartOptions'
```

### Things to Remember

- When you assign an object literal to a variable with a known type or pass it as an argument to a function, it undergoes excess property checking.
  - "ê°ì²´ ë¦¬í„°ëŸ´"ì„ ë³€ìˆ˜ì— í• ë‹¹í•˜ê±°ë‚˜ í•¨ìˆ˜ì— ë§¤ê°œë³€ìˆ˜ë¡œ ì „ë‹¬í•  ë•Œ, ì‰ì—¬ ì†ì„± ì²´í¬ excess property checkê°€ ìˆ˜í–‰ëœë‹¤
- Excess property checking is an effective way to find errors, but it is distinct from the usual structural assignability checks done by the TypeScript type checker. Conflating these processes will make it harder for you to build a mental model of assignability. TypeScript types are not "closed" (pass:[Item 4]).

  - ì‰ì—¬ ì†ì„± ì²´í¬ëŠ” ì˜¤ë¥˜ë¥¼ ì°¾ëŠ” íš¨ê³¼ì ì¸ ë°©ë²•(ê°ì²´ ë¦¬í„°ëŸ´, íƒ€ì… ì—ëŸ¬)ì´ì§€ë§Œ, êµ¬ì¡°ì  í• ë‹¹ ê°€ëŠ¥ì„± ì²´í¬ì™€ëŠ” ì—­í• ì´ ë‹¤ë¥´ë‹¤(êµ¬ì¡°ì  )

    | ê²€ì‚¬                    | ì˜ì–´                     | í‚¤ì›Œë“œ                         | ì„¤ëª…                                                                                        |
    | ----------------------- | ------------------------ | ------------------------------ | ------------------------------------------------------------------------------------------- |
    | ì´ˆê³¼ ì†ì„± ê²€ì‚¬          | Excess Property Checking | ì˜¤íƒ€ë‚˜ ì˜ë„ì¹˜ ì•Šì€ ì†ì„±ì„ ê°ì§€ | ê°ì²´ ë¦¬í„°ëŸ´ì„ ë‹¤ë¥¸ íƒ€ì…ì— í• ë‹¹í•  ë•Œ ì˜ˆìƒì¹˜ ëª»í•œ ì†ì„±ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ì—¬ ì˜¤ë¥˜ë¥¼ ì°¾ì•„ë‚´ëŠ” ê¸°ëŠ¥ |
    | êµ¬ì¡°ì  í• ë‹¹ ê°€ëŠ¥ì„± ê²€ì‚¬ | Structural Assignability | êµ¬ì¡°ì  íƒ€ì´í•‘                  | íƒ€ì… ê°„ì˜ í˜¸í™˜ì„±ì„ ê²°ì •í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ì¼ë°˜ì ì¸ ê²€ì‚¬                                         |

  - Excess Property Checking Example:

    ```tsx
    interface Person {
      name: string;
      age: number;
    }

    const person: Person = {
      name: "Alice",
      age: 25,
      extraProp: "unexpected", // Error: Object literal may only specify known properties, and 'extraProp' does not exist in type 'Person'.
    };
    ```

  - Structural Assignability Example:

    ```tsx
    interface Point {
      x: number;
      y: number;
    }

    const point = { x: 10, y: 20, z: 30 };

    const assignablePoint: Point = point;
    // ì˜¤ë¥˜ ì—†ìŒ! 'point' ê°ì²´ì—ëŠ” 'Point' ì¸í„°í˜ì´ìŠ¤ì—ì„œ ìš”êµ¬í•˜ëŠ” ì†ì„±ì´ ëª¨ë‘ í¬í•¨ë˜ì–´ ìˆìŒ.
    ```

- Be aware of the limits of excess property checking: introducing an intermediate variable will remove these checks.
  - ì¶”ê°€ ì†ì„± ì²´í¬ì˜ í•œê³„ (ì¤‘ê°„ ë‹¨ê³„ì˜ ì„ì‹œ ë³€ìˆ˜)
- A "weak type" is an object type with only optional properties. For these types, assignability checks require at least one matching property.
  - weak typeì€ ì˜µì…”ë„ ì†ì„±ìœ¼ë¡œë§Œ ì´ë£¨ì–´ì§„ íƒ€ì…
  - ì ì–´ë„ í•˜ë‚˜ì˜ ì†ì„±ì´ ë§ì•„ì•¼ í• ë‹¹

---

## ì•„ì´í…œ 12: í•¨ìˆ˜ í‘œí˜„ì‹ì— íƒ€ì… ì ìš©í•˜ê¸° Apply Types to Entire Function Expressions When Possible

### statement vs expression

```tsx
function rollDice1(sides: number): number {} // ë¬¸ì¥ Statement
const rollDice2 = function (sides: number): number {}; // í‘œí˜„ì‹ Expression
const rollDice3 = (sides: number): number => {}; // í‘œí˜„ì‹ expression
```

### í•¨ìˆ˜ ì „ì²´ì˜ íƒ€ì…ì„ ì •ì˜í•˜ê¸°

```tsx
type DiceRollFn = (sides: number) => number;
// í•¨ìˆ˜ íƒ€ì…ì˜ ì„ ì–¸ì˜ ëª©ì : ë¶ˆí•„ìš”í•œ ì½”ë“œì˜ ë°˜ë³µì„ ì¤„ì¸ë‹¤ (ë°˜ë³µë˜ëŠ” í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ í†µí•©)
// í•¨ìˆ˜ êµ¬í˜„ë¶€ê°€ ë¶„ë¦¬ë˜ì–´ ë¡œì§ì´ ë¶„ëª…í•´ì§„ë‹¤.
const rollDice: DiceRollFn = (sides) => {};
```

- ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê³µí†µ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜: ê³µí†µ ì½œë°±í•¨ìˆ˜ë¥¼ ìœ„í•œ íƒ€ì… ì„ ì–¸

  - JSì˜ [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent), Reactì˜ MouseEventHandler
  - MouseEventHandlerëŠ” í•¨ìˆ˜ ì „ì²´ì— ì ìš©í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì´ë‹¤.

    ```tsx
    // @types/react/index.d.ts
    // MouseEventHandler
    // Element Të¥¼ ì œë„¤ë¦­ìœ¼ë¡œ ë°›ì•„ì„œ MouseEvent<T>ë¡œ EventHandler íƒ€ì…ì— ë„˜ê¹€
    type MouseEventHandler<T = Element> = EventHandler<MouseEvent<T>>;

    // (ì°¸ê³ ìš©)EventHandler
    type EventHandler<E extends SyntheticEvent<any>> = {
      bivarianceHack(event: E): void;
    }["bivarianceHack"];
    ```

- ì‹œê·¸ë‹ˆì²˜ê°€ ì¼ì¹˜í•˜ëŠ” ë‹¤ë¥¸ í•¨ìˆ˜
  - ì˜ˆì‹œ: fetch íƒ€ì… í™œìš©í•˜ê¸°

```tsx
// typescript/lib/lib.dom.d.tsì— ìˆëŠ” fetch íƒ€ì…
declare function fetch(
  input: RequestInfo,
  init?: RequestInit
): Promise<Response>;

// ë‹¤ë¥¸ íŒŒì¼ì—ì„œ í™œìš©
// í•¨ìˆ˜ ì „ì²´ì— íƒ€ì…(typeof fetch)ë¥¼ ì ìš©í•´, ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆê²Œ í•œë‹¤
const checkedFetch: typeof fetch = async (input, init) => {
  const response = await fetch(input, init);
  if (!response.ok) {
    throw new Error(`Request failed: ${response.status}`);
  }
  return response;
};
```

### Things to Remember

- Consider applying type annotations to entire function expressions, rather than to their parameters and return type.
  - íŒŒë¼ë¯¸í„°ì™€ ë¦¬í„´ íƒ€ì…ì„ ê°œë³„ë¡œ ì„ ì–¸í•˜ì§€ ì•Šê³ , ì „ì²´ í•¨ìˆ˜ í‘œí˜„ì‹ì˜ íƒ€ì…ì„ ì„ ì–¸í•˜ë„ë¡ í•œë‹¤
- If you're writing the same type signature repeatedly, factor out a function type or look for an existing one.
  - ë°˜ë³µì ì¸ í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì‘ì„±í•˜ì§€ ë§ê³ , í•¨ìˆ˜ íƒ€ì…ì„ ë¶„ë¦¬í•´ë‚´ê±°ë‚˜ & ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íƒ€ì…ì„ ì°¾ë„ë¡ í•œë‹¤
- If you're a library author, provide types for common callbacks.
  - ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë§Œë“¤ ë•Œ, ê³µí†µ ì½œë°± íƒ€ì…ì„ ì œê³µí•˜ì
- Use typeof fn to match the signature of another function, or Parameters and a rest parameter if you need to change the return type.
  - ë‹¤ë¥¸ í•¨ìˆ˜ì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ `typeof fn`ì„ ì‚¬ìš©í•œë‹¤

---

## ì•„ì´í…œ 13 íƒ€ì…ê³¼ ì¸í„°í˜ì´ìŠ¤ì˜ ì°¨ì´ì  ì•Œê¸° Know the Differences Between type and interface

- named typeì„ ì •ì˜í•˜ëŠ” ë°©ë²•
  - typeê³¼ interfaceë¡œ ì •ì˜
  - classëŠ” ê°’+íƒ€ì…

### ì ‘ë‘ì‚¬ I, Të¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì„ ì´ìœ 

- (ê¶Œì¥ì‚¬í•­) ì ‘ë‘ì‚¬ë¡œ I, Të¥¼ ë¶™ì´ëŠ” ê²ƒì€ C# ê´€ë¡€ì¸ë°, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì´ˆê¸°ì— ì‚¬ìš©í–ˆì—ˆì§€ë§Œ ì§€ê¸ˆì€ ì»¤ë®¤ë‹ˆí‹°ì—ì„œ ê¶Œì¥í•˜ì§€ ì•ŠëŠ” ìŠ¤íƒ€ì¼ì´ë‹¤.
- (íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì»´íŒŒì¼ëŸ¬) íƒ€ì…ì´ë‚˜ ì¸í„°í˜ì´ìŠ¤ ì´ë¦„ì— êµ³ì´ Ië‚˜ Të¥¼ ë¶™ì´ì§€ ì•Šì•„ë„ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì»´íŒŒì¼ëŸ¬ê°€ ì´ë¥¼ ëª…í™•íˆ êµ¬ë¶„í•  ìˆ˜ ìˆë‹¤.
- (ê°€ë…ì„±) IUserë³´ë‹¤ Userê°€ ë” ì§ê´€ì ì´ë©°, TProductë³´ë‹¤ Productê°€ ë” ëª…í™•

### typeê³¼ interface

- ê³µí†µ: ì¶”ê°€ ì†ì„± ê²€ì‚¬, ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜, í•¨ìˆ˜ íƒ€ì… ì •ì˜, ì œë„¤ë¦­, í´ë˜ìŠ¤ implements
- í™•ì¥
  - interface: íƒ€ì…ì„ í™•ì¥
    - ìœ ë‹ˆì˜¨ íƒ€ì…ê³¼ ê°™ì€ ë³µì¡í•œ íƒ€ì… í™•ì¥ x (ìœ ë‹ˆì˜¨ ì¸í„°í˜ì´ìŠ¤ëŠ” ì—†ë‹¤)
  - type: ì¸í„°í˜ì´ìŠ¤ë¥¼ í™•ì¥

```tsx
// í™•ì¥ extends
interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState & { population: number };

// í´ë˜ìŠ¤ implements
class StateT implements TState {
  name: string = "";
  capital: string = "";
}
class StateI implements IState {
  name: string = "";
  capital: string = "";
}
```

### type í™œìš©

- íƒ€ì… union

  ```tsx
  type AorB = "a" | "b";
  ```

- ë³„ë„ì˜ íƒ€ì…ì„ í•˜ë‚˜ì˜ ë³€ìˆ˜ëª…ìœ¼ë¡œ ë§¤í•‘í•  ë•Œ

  ```tsx
  type Input = {
    /* ... */
  };
  type Output = {
    /* ... */
  };
  interface VariableMap {
    [name: string]: Input | Output; // union
  }
  ```

- union íƒ€ì…ì— ì†ì„±ì„ ì¶”ê°€í•œ íƒ€ì…

  ```tsx
  type NamedVariable = (Input | Output) & { name: string };
  ```

- íŠœí”Œ, ë°°ì—´

  - interfaceë¡œ êµ¬í˜„í•˜ê²Œ ë˜ë©´, concatê³¼ ê°™ì€ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
  - ì§ê´€ì ì´ì§€ ì•ŠìŒ
  - ìˆ«ì ì¸ë±ìŠ¤ ë¬¸ì œ (ì•„ì´í…œ 16)

  ```tsx
  type Pair = [a: number, b: number];
  type StringList = string[];
  type NamedNums = [string, ...number[]];

  const í˜ì–´: Pair = [0, 1];
  const ë„¤ì„ë“œë„˜ì¦ˆ: NamedNums = ["ğŸ", 0, 1];

  // Interfaceë¡œ êµ¬í˜„í•˜ëŠ” ê²½ìš°
  // íƒ€ì…ì˜ í˜•íƒœì™€, íƒ€ì… ì—ëŸ¬ì˜ ë©”ì‹œì§€(í•˜ë‹¨)ê°€ ì§ê´€ì ì´ì§€ ì•ŠìŒ
  interface Tuples {
    0: number;
    1: number;
    length: 2;
  }
  ```

  - type íŠœí”Œ

    - lengthê°€ 1

      ```
      Type '[number]' is not assignable to type 'Pair'.
        Source has 1 element(s) but target requires 2
      ```

    - lengthê°€ 3
      ```
      Type '[number, number, number]' is not assignable to type 'Pair'.
      Source has 3 element(s) but target allows only 2.(2322)
      ```

  - interfaceë¡œ êµ¬í˜„í•˜ëŠ” ê²½ìš°

    - lengthê°€ 1
      ```
      Property '1' is missing in type '[number]' but required in type 'Tuples'.
      ```
      ![image](https://github.com/dusunax/blog/assets/94776135/5fccf6fb-baf7-4955-a7c1-ea5449edaa15)
    - lengthê°€ 3
      ```
      Type '[number, number, number]' is not assignable to type 'Tuples'.
        Types of property 'length' are incompatible.
          Type '3' is not assignable to type '2'.(2322)
      ```
      ![image](https://github.com/dusunax/blog/assets/94776135/e76d944a-1b89-4ce5-a1c1-9cdc9a386363)

### ë³´ê°• augment

- interfaceë§Œ ê°€ëŠ¥

```tsx
interface IState {
  name: string;
  capital: string;
}
interface IState {
  // ë³´ê°•ë¨!
  population: number;
}
const wyoming: IState = {
  name: "Wyoming",
  capital: "Cheyenne",
  population: 578_000,
}; // OK
```

- ë³´ê°•ì„ ë³€ìˆ˜ ì„ ì–¸&í• ë‹¹ì˜ í•˜ë‹¨ì—ì„œ ì§„í–‰í•˜ëŠ” ê²½ìš°ì—ë„ íƒ€ì… ì—ëŸ¬ ì—†ìŒ (ì „ì—­ ë²”ìœ„)
- ì¶©ëŒ ì—†ìŒ: ê° ë³´ê°•ì€ ì´ì „ ì„ ì–¸ê³¼ ì¶©ëŒí•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤(ì˜ˆ: ë™ì¼í•œ ì´ë¦„ì˜ ì†ì„±ì´ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§€ë©´ ì•ˆ ë¨)
  ![image](https://github.com/dusunax/blog/assets/94776135/3163fe07-8325-4892-a671-2d643f73e26c)
- ì˜ˆì œì˜ ì„¤ëª…ì²˜ëŸ¼ íƒ€ì…ì„ ì–¸ íŒŒì¼(d.ts) ë“±ì—ì„œ ì‚¬ìš©ìê°€ ì±„ìš°ëŠ” ê²½ìš°ì—ë§Œ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì í•©í•  ê²ƒì´ë¼ ìƒê°

### ì„ ì–¸ ë³‘í•© declaration merging,

- TSëŠ” ì—¬ëŸ¬ ë²„ì „ì˜ JS í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì—¬ëŸ¬ íƒ€ì…ì„ ëª¨ì•„ ë³‘í•©í•œë‹¤
- ì˜ˆì‹œ
  - `lib.es5.d.ts`ì˜ `interface Array<T>`
  - tsconfig.json libì— ES2015ë¥¼ ì¶”ê°€í•˜ë©´? íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” `lib.es2015.d.ts`ì˜ `interface Array<T>`ë¥¼ ë³‘í•©í•œë‹¤ (findì™€ ê°™ì€ ë©”ì„œë“œë¥¼ í¬í•¨)

### Type or Interface?

- ë³µì¡í•œ íƒ€ì…: íƒ€ì… ë³„ì¹­
- ê°„ë‹¨í•œ íƒ€ì…: ì¼ê´€ì„±ê³¼ ë³´ê°•ì˜ ê´€ì ì—ì„œ ê³ ë ¤í•˜ê¸°
  - ì½”ë“œ ë² ì´ìŠ¤ì˜ ì¼ê´€ì„±ì„ ë”°ë¦„
  - í–¥í›„ì˜ ë³´ê°•ì˜ ê°€ëŠ¥ì„±ì´ ìˆëŠ”ê°€
    - APIì— ëŒ€í•œ íƒ€ì… ì„ ì–¸: interface
    - í”„ë¡œì íŠ¸ ë‚´ë¶€ì—ì„œ ì‚¬ìš©í•˜ëŠ” íƒ€ì…: type

### Things to Remember

- Understand the differences and similarities between type and interface.
  - íƒ€ì…ê³¼ ì¸í„°í˜ì´ìŠ¤ì˜ ì°¨ì´ì  & ë¹„ìŠ·í•œ ì  ì•Œê¸°
- Know how to write the same types using either syntax.
  - ê° ë¬¸ë²•ìœ¼ë¡œ ì‘ì„±í•˜ëŠ” ë²• ì•Œê¸°
- Be aware of declaration merging for interface and type inlining for type.
  - ì„ ì–¸ ë³‘í•©ê³¼ ë³´ê°• ì•Œê¸°
- For projects without an established style, prefer interface to type for object types.
  - ì½”ë“œ ë² ì´ìŠ¤ ìŠ¤íƒ€ì¼ì´ ì—†ìœ¼ë©´ => í”„ë¡œì íŠ¸ì— ì–´ë–¤ ë¬¸ë²•ì„ ì‚¬ìš©í•  ì§€ ê²°ì •í•  ë•Œ, ì¼ê´€ëœ ìŠ¤íƒ€ì¼ í™•ë¦½
  - ì¼ê´€ì„±ê³¼ ë³´ê°•ì˜ ê´€ì ì—ì„œ ê³ ë ¤

---

## ì•„ì´í…œ 14: íƒ€ì… ì—°ì‚°ê³¼ ì œë„ˆë¦­ ì‚¬ìš©ìœ¼ë¡œ ë°˜ë³µ ì¤„ì´ê¸° Use Type Operations and Generic Types to Avoid Repeating Yourself

> ì˜ë¬¸ ì„œì ì—ì„œëŠ” Item 15

### DRY, don't repeat yourself

- íƒ€ì…ì˜ ì¤‘ë³µ ì¤„ì´ê¸°
  - íƒ€ì…ì— ì´ë¦„ ë¶™ì´ê¸°
  - í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ëª…ëª…ëœ íƒ€ì…ìœ¼ë¡œ ë¶„ë¦¬í•˜ê¸°
  - ì¸í„°í˜ì´ìŠ¤ í™•ì¥
  - íƒ€ì… ê°„ ë§¤í•‘

### íƒ€ì…ì— ì´ë¦„ ë¶™ì´ê¸° named type

```tsx
interface Point2D {
  x: number;
  y: number;
}
function distance(a: Point2D, b: Point2D) {
  /* ... */
}
```

### í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ëª…ëª…ëœ íƒ€ì…ìœ¼ë¡œ ë¶„ë¦¬í•˜ê¸° function signature

```tsx
type HTTPFunction = (url: string, opts: Options) => Promise<Response>;
const get: HTTPFunction = (url, opts) => {
  /* ... */
};
const post: HTTPFunction = (url, opts) => {
  /* ... */
};
```

### ì¸í„°í˜ì´ìŠ¤ í™•ì¥ extends interface

```tsx
interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate extends Person {
  birth: Date;
}

// ë˜ëŠ” type intersectiondë¥¼ ì“¸ ìˆ˜ë„ ìˆìŒ
type PersonWithBirthDate = Person & { birth: Date };
```

### ë¶€ë¶„ ì§‘í•© subset

```tsx
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

// Stateì„ ì¸ë±ì‹±
interface TopNavState {
  userId: State["userId"];
  pageTitle: State["pageTitle"];
  recentFiles: State["recentFiles"];
}

// ë§¤í•‘ëœ íƒ€ì…
// ë°°ì—´ì˜ í•„ë“œë¥¼ ë£¨í”„ ë”
type TopNavState = {
  [K in "userId" | "pageTitle" | "recentFiles"]: State[K];
};

// Pick
// type Pick<T, K extends keyof T> = { [P in K]: T[P]; }
type TopNavState = Pick<State, "userId" | "pageTitle" | "recentFiles">;
```

- Pickì€ ì œë„ˆë¦­ íƒ€ì…ì´ë‹¤
  - í•¨ìˆ˜ì—ì„œ ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì•„ì„œ ê²°ê³¼ê°’ë¥¼ ë°˜í™˜í•˜ë“¯, Tì™€ Kë¥¼ ë°›ì•„ì„œ ê²°ê³¼ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤.

### ì˜ˆì‹œ: íƒœê·¸ë¥¼ ë¶™ì´ê¸° ìœ„í•´ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°

```tsx
interface SaveAction {
  type: "save";
  // ...
}
interface LoadAction {
  type: "load";
  // ...
}
type Action = SaveAction | LoadAction;
// type ActionType = "save" | "load"; // Repeated types!

type ActionType = Action["type"];
//   ^? type ActionType = "save" | "load"
// ì¤‘ë³µ ì½”ë“œ ì—†ì´ Actionì„ ì¸ë±ì‹±

type ActionRecord = Pick<Action, "type">;
//   ^? type ActionRecord = { type: "save" | "load"; }
// Pickê³¼ ì¸ë±ì‹±ì€ í˜•íƒœê°€ ë‹¤ë¦„
```

### ì˜ˆì‹œ: ìƒì„±í•˜ê³  ë‚œ ë‹¤ìŒ ì—…ë°ì´íŠ¸ ë˜ëŠ” í´ë˜ìŠ¤

- íƒ€ì… ëŒ€ë¶€ë¶„ì´ ì„ íƒì  í•„ë“œ
  - `[k in keyof Options]?: Options[k]`
  - ë§¤í•‘ëœ íƒ€ì…ì„ ìˆœíšŒí•˜ë©° Option ë‚´ k ê°’ ì†ì„± ì°¾ê¸° => ê° ì†ì„±ì„ optionalí•˜ê²Œ ë§Œë“¤ê¸°

```tsx
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}
class UIWidget {
  constructor(init: Options) {}
  update(options: OptionsUpdate) {}
}

// OptionsUpdate ì •ì˜í•˜ê¸°
// ğŸš« ì¤‘ë³µ ì½”ë“œ
interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}

// inìœ¼ë¡œ ë£¨í”„
type OptionsUpdate = { [k in keyof Options]?: Options[k] };

// keyofì€? ì†ì„± íƒ€ì…ì˜ ìœ ë‹ˆì˜¨ ë°˜í™˜
type OptionsKeys = keyof Options;
//   ^? type OptionsKeys = keyof Options
//      (equivalent to "width" | "height" | "color" | "label")

// Partial íŒ¨í„´
class UIWidget {
  constructor(init: Options) {}
  update(options: Partial<Options>) {}
}
```

### ê°’ì— í˜•íƒœì— í•´ë‹¹í•˜ëŠ” íƒ€ì… ì •ì˜

- value to type

```tsx
const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: "#00FF00",
  label: "VGA",
};

// typeofì€ jsì˜ typeofì´ ì•„ë‹˜
// tsì˜ typeof: `ê°’`ì„ ì½ì–´ì„œ, `íƒ€ì…`ì„ ë°˜í™˜í•©ë‹ˆë‹¤
type Options = typeof INIT_OPTIONS;
```

- return value to type

```tsx
// ReturnType ì œë„ˆë¦­
type UserInfo = ReturnType<typeof getUserInfo>;
```

- DRY ì›ì¹™ì„ ì§€ì¹  ë•Œ ì œë„¤ë¦­ì´ ìœ ìš©í•˜ê²Œ ì‚¬ìš©ë¨~!
  - ë§¤ê°œë³€ìˆ˜ ì œí•œ

```tsx
type Pick<T, K extends keyof T> = {
  // extendsëŠ” í™•ì¥ì´ ì•„ë‹Œ ë¶€ë¶„ ì§‘í•©
  [k in K]: T[k];
};
```

### Things to Remember

- The DRY (don't repeat yourself) principle applies to types as much as it applies to logic.
  - DRY ì›ì¹™ì„ íƒ€ì…ì—ë„ ìµœëŒ€í•œ ì ìš©
- Name types rather than repeating them. Use extends to avoid repeating fields in interfaces.
  - íƒ€ì…ì„ ë°˜ë³µí•˜ì§€ ë§ê³  name typeì„ ì‚¬ìš©í•˜ì. field ì¤‘ë³µì—ëŠ” interface extendsë¥¼ ì‚¬ìš©í•˜ì
- Build an understanding of the tools provided by TypeScript to map between types. These include keyof, typeof, indexing, and mapped types.
  - ë§¤í•‘ì„ ìœ„í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ë„êµ¬ë¥¼ ì•Œì•„ë‘ì: keyof, typeof, indexing, and mapped types
- Generic types are the equivalent of functions for types. Use them to map between types instead of repeating type-level operations.
  - íƒ€ì… ë ˆë²¨ì˜ ë°˜ë³µ ì½”ë“œë¥¼ ì œê±°í•˜ê³ , ì œë„¤ë¦­ íƒ€ì…ì„ ì‚¬ìš©í•˜ì
  - ì œë„¤ë¦­ íƒ€ì…ì€ íƒ€ì…ì„ ìœ„í•œ í•¨ìˆ˜ì™€ ê°™ë‹¤.
- Familiarize yourself with generic types defined in the standard library, such as Pick, Partial, and ReturnType.
  - í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ëœ ì œë„¤ë¦­ íƒ€ì…ì„ ì‚¬ìš©í•˜ì (ê³ ìƒí•˜ê¸° ì‹«ìœ¼ë©´)
  - Pick, Partial, ReturnType
- Avoid over-application of DRY: make sure the properties and types you're sharing are really the same thing.
  - ì¤‘ë³µëœ íƒ€ì…ì˜ ê²½ìš°: ê¸°ë³¸ì ìœ¼ë¡œ ì„œë¡œ ë‹¤ë¥¸ ì†ì„±ê³¼ ì˜ë¯¸ë¥¼ ê°€ì§ˆ ë•ŒëŠ” DRYë¥¼ í”¼í•˜ê¸°
  - ë™ì¼í•œ ìœ í˜•ìœ¼ë¡œ ê²°í•©í•˜ëŠ” ê²ƒì´ ì ì ˆí•˜ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤.

---

## Item 15: ë™ì  ë°ì´í„°ì— ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì ìš©í•˜ê¸°: Prefer More Precise Alternatives to Index Signatures

> ì˜ë¬¸ ì„œì ì—ì„œëŠ” Item 16

### ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ Index Signatures

```tsx
// [í‚¤_ì´ë¦„: í‚¤_íƒ€ì…]: ê°’_íƒ€ì…
type Rocket = { [ì†ì„±: string]: string }; // index signature
// - í‚¤ ì´ë¦„ìœ¼ë¡œ ë¬´ì—‡ì´ë“  ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ìë™ ì™„ì„± x
// - í‚¤ë§ˆë‹¤ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤.

const rocket: Rocket = {
  name: "Falcon 9",
  variant: "v1.0",
  thrust: "4,940 kN",
};
```

- ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ëŠ” ë™ì  ë°ì´í„°ë¥¼ í‘œí˜„í•  ë•Œ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ë™ì ì¸ ë°ì´í„°ë¥¼ í‘œí˜„í•˜ê³ , ê°ì²´ë¡œ ë§¤í•‘í•˜ê³ , ë¦¬í„´ ê°’ì„ ë‹¨ì–¸ë¬¸ì„ ì‚¬ìš©

### ì—°ê´€ ë°°ì—´ associative array

- í”„ë¡œí† íƒ€ì… ì²´ì¸ ë¬¸ì œ ìš°íšŒ (ì•„ì´í…œ 58)

```tsx
//
interface Row1 {
  [column: string]: number;
}

// ì„ íƒì  í•„ë“œ
interface Row2 {
  a: number;
  b?: number;
  c?: number;
  d?: number;
} // Better

// ìœ ë‹ˆì˜¨ íƒ€ì…
type Row3 =
  | { a: number }
  | { a: number; b: number }
  | { a: number; b: number; c: number }
  | { a: number; b: number; c: number; d: number }; // Also better: ë²ˆê±°ë¡œì›€

// Record
type Vec3D = Record<"x" | "y" | "z", number>;
//   ^? type Vec3D = {
//        x: number;
//        y: number;
//        z: number;
//      }
```

### unknown props

```tsx
interface ButtonProps {
  title: string;
  onClick: () => void;
  [otherProps: string]: unknown; // unknown props
}

renderAButton({
  title: "Roll the dice",
  onClick: () => alert(1 + Math.floor(20 * Math.random())),
  theme: "Solarized", // ì¶”ê°€ props
});
```

### Things to Remember

- Understand the drawbacks of index signatures: much like any, they erode type safety and reduce the value of language services.
  - index signatureë¥¼ ì‚¬ìš©í•˜ë©´ anyì²˜ëŸ¼ ì•ˆì •ì„±ì´ ë–¨ì–´ì§€ê³ , ì–¸ì–´ ì„œë¹„ìŠ¤ë¥¼ ì œê³µ ë°›ê¸° í˜ë“¤ë‹¤.
  - undefinedë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•œë‹¤
- Prefer more precise types to index signatures when possible: interfaces, Map, Records, mapped types, or index signatures with a constrained key space.
  - ë” ì •í™•í•œ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤: interfaces, Map, Records, mapped types

---

## ì•„ì´í…œ 16: number ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ë³´ë‹¤ Array, íŠœí”Œ, ArrayLikeì„ ì‚¬ìš©í•˜ê¸° Avoid Numeric Index Signatures

> ì˜ë¬¸ ì„œì ì—ì„œëŠ” Item 17

- ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ê°ì²´ë€ í‚¤/ê°’ ìŒì˜ ëª¨ìŒì´ë‹¤.
- í‚¤ëŠ” ë³´í†µ ë¬¸ìì—´ì´ë©°, ê°’ì€ ë¬´ì—‡ì´ë“  ë  ìˆ˜ ìˆë‹¤.

### ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ê°ì²´

- ë³µì¡í•œ ê°ì²´ë¥¼ í‚¤ë¡œ ì‚¬ìš©í•˜ë ¤ í•  ë•Œ?
  ![image](https://github.com/dusunax/blog/assets/94776135/aef8122d-efeb-4fbd-8146-ca45270a453a)
- ìˆ«ìë¥¼ í‚¤ë¡œ ì‚¬ìš©í•˜ë©´? ëŸ°íƒ€ì„ì´ ë¬¸ìì—´ë¡œ ë³€í™˜í•œë‹¤.

  ```tsx
  const x = { 1: 1 };
  console.log(x); // {"1": 1}
  ```

- ë°°ì—´ì€? ê°ì²´ë‹¤.

  - ìˆ«ì ì¸ë±ìŠ¤ëŠ”? ë¬¸ìì—´ë¡œ ë³€í™˜ë˜ì–´ ì‚¬ìš©ëœë‹¤.
  - `x["1"]` ë¬¸ìì—´ í‚¤ë¥¼ ì‚¬ìš©í•´ì„œ ë°°ì—´ ìš”ì†Œì— ì ‘ê·¼í•  ìˆ˜ ìˆìŒ
  - Object.keys()ë¡œ ë°°ì—´ì˜ í‚¤ë¥¼ ë‚˜ì—´í•˜ë©´? í‚¤ëŠ” ë¬¸ìì—´ì´ë‹¤

  ```tsx
  let array1 = [1, 2, 3];
  console.log(array1["0"]); // 1

  for (const key in array1) {
    console.log(key, array1[key]);
    // "0", 1
    // "1", 2
    // "2", 3
  }
  ```

### for inì€ ëŠë¦¬ë‹¤

- íƒ€ì…ì´ ë¶ˆí™•ì‹¤í•˜ë‹¤ë©´ for-in ë£¨í”„ëŠ” ëŠë¦¬ë‹¤
  - ê°ì²´ì˜ ëª¨ë“  ì—´ê±° ê°€ëŠ¥í•œ ì†ì„±ê³¼ í”„ë¡œí† íƒ€ì… ì²´ì¸ì˜ ì†ì„±ê¹Œì§€ ê²€ì‚¬í•˜ë¯€ë¡œ ëŠë¦¬ë‹¤
  - ì´ë¡œ ì¸í•´ ì†ì„± í•„í„°ë§ê³¼ ìˆœì„œ ìœ ì§€ ë“± ì¶”ê°€ì ì¸ ì‘ì—…ì´ í•„ìš”í•´ ì„±ëŠ¥ì— ì˜í–¥ì„ ë¯¸ì¹œë‹¤
- for-ofë‚˜ for(;;) ë£¨í”„ ì‚¬ìš©í•˜ê¸°

### ArrayLike

- number íƒ€ì…ì˜ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜
  - ìˆ«ìë¥¼ ì‚¬ìš©í•´ ì¸ë±ìŠ¤ í•­ëª©ì„ ì§€ì •í•œë‹¤ë©´, ìˆ«ì ì†ì„±ì— ëŒ€í•œ ì˜¤í•´ë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤
- Arrayì˜ íƒ€ì…ì„ ê°€ì§€ì§€ ì•Šì€, ì–´ë–¤ ê¸¸ì´ë¥¼ ê°–ê³  ìˆëŠ” ë°°ì—´ê³¼ ë¹„ìŠ·í•œ í˜•íƒœì˜ íŠœí”Œì„ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´?

  - ArrayLikeì„ ì‚¬ìš©í•œë‹¤

  ```tsx
  // ArrayLikeëŠ” ìˆ«ì ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì™€ lengthë¥¼ ê°€ì§
  const tupleLike: ArrayLike<string> = {
    "0": "A",
    "1": "B",
    length: 2,
  }; // OK
  ```

### Things to Remember

- Understand that arrays are objects, so their keys are strings, not numbers. number as an index signature is a purely TypeScript construct designed to help catch bugs.
  - ë°°ì—´ì€ ê°ì²´ì´ë¯€ë¡œ, í‚¤ëŠ” ë¬¸ìì—´ì´ë‹¤.
  - ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì˜ `ë°°ì—´[number]`ì—ì„œ numberëŠ” ë²„ê·¸ë¥¼ ì¡ê¸° ìœ„í•œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œì´ë‹¤.
- Prefer Array, tuple, ArrayLike, or Iterable types to using number in an index signature yourself.
  - ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì˜ numberë¥¼ ì‚¬ìš©í•˜ê¸°ë³´ë‹¤ Arrayë‚˜ íŠœí”Œ, ArrayLikeì„ ì‚¬ìš©í•˜ì

---

## ì•„ì´í…œ 17 ë³€ê²½ ê´€ë ¨ëœ ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•´ readonly ì‚¬ìš©í•˜ê¸°: Use readonly to Avoid Errors Associated with Mutation

> ì˜ë¬¸ ì„œì ì—ì„œëŠ” Item 14

- readonly ì ‘ê·¼ ì œì–´ì
  - ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì„ ì–¸

### readonly number[]

- readonly number[]ëŠ” number[]ì˜ ì„œë¸Œíƒ€ì…ì´ë‹¤
- ë°°ì—´ì˜ ìš”ì†Œë¥¼ ì½ì„ ìˆ˜ëŠ” ìˆì§€ë§Œ, ì“¸ ìˆ˜ëŠ” ì—†ë‹¤
  ![image](https://github.com/dusunax/blog/assets/94776135/9aa6febd-5fe1-4c7c-b350-081dfd8f41ed)
- lengthë¥¼ ì½ì„ ìˆ˜ëŠ” ìˆì§€ë§Œ, ë°”ê¿€ ìˆ˜ ì—†ë‹¤
- ë°°ì—´ì„ ë³€ê²½í•˜ëŠ” ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ì—†ë‹¤

```tsx
// triangular number ì‚¼ê°ìˆ˜ë¥¼ ì¶œë ¥í•˜ëŠ” ì½”ë“œ
// 1, 1+2, 1+2+3, ...

function printTriangles(n: number) {
  const nums = [];
  for (let i = 0; i < n; i++) {
    nums.push(i);
    console.log(arraySum(nums));
  }
}
printTriangles(5);

function arraySum(arr: number[]) {
  let sum = 0;
  for (const num of arr) {
    sum += num;
  }
  return sum;
}
```

### í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ë¥¼ readonlyë¡œ ì„ ì–¸í–ˆì„ ë•Œ

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ë§¤ê°œë³€ìˆ˜ê°€ í•¨ìˆ˜ ë‚´ì—ì„œ ë³€ê²½ì´ ì¼ì–´ë‚˜ëŠ”ì§€ ì²´í¬í•œë‹¤
- í˜¸ì¶œí•˜ëŠ” ìª½ì—ì„œ í•¨ìˆ˜ê°€ ë§¤ê°œë³€ìˆ˜ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ë³´ì¥ì„ ë°›ëŠ”ë‹¤
- ëª…ì‹œì ìœ¼ë¡œ ì–¸ê¸‰í•˜ì§€ ì•ŠëŠ”í•œ, í•¨ìˆ˜ê°€ ë§¤ê°œë³€ìˆ˜ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤ê³  ê°€ì •í•˜ì§€ë§Œ, ì•”ë¬µì ì¸ ë°©ë²•ì´ë¯€ë¡œ íƒ€ì…ì²´í¬ì— ë¬¸ì œë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤
- ë‹¨ì 
  - í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ë‹¤ë¥¸ í•¨ìˆ˜ë„ readonlyë¡œ ë³€ê²½ => íƒ€ì… ì•ˆì •ì„±ì„ ë†’ì„
  - ë‹¤ë¥¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ìˆëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²½ìš° ë‹¨ì–¸ë¬¸ì„ ì‚¬ìš©í•´ì•¼ í•˜ëŠ” ê²½ìš° ë‹¨ì–¸í•´ì•¼í•¨
- ì¥ì 
  - ì§€ì—­ ë³€ìˆ˜ì™€ ê´€ë ¨ëœ ë³€ê²½ ì˜¤ë¥˜ ë°©ì§€

### shallow ë³€ê²½ ë°©ì§€

- ì–•ì€(Shallow) ë³€ê²½ ë°©ì§€ì´ë¯€ë¡œ, ì¤‘ì²©ëœ ë°°ì—´ì˜ ë‚´ë¶€ ê°’ì€ ì—¬ì „íˆ ë³€ê²½í•  ìˆ˜ ìˆìŒ (ê°ì²´ì— ì ìš©í•˜ëŠ” Readonly ì œë„¤ë¦­ì˜ ê²½ìš°ë„ ë§ˆì°¬ê°€ì§€)
- DeepReadonlyëŠ”? ts-essential ë¼ì´ë¸ŒëŸ¬ë¦¬. ê¹Šì€ readonly íƒ€ì…
- ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì—ë„ readonly ì“¸ ìˆ˜ ìˆë‹¤

```tsx
// let obj: {readonly [k: string]: number | string} = {}
let obj: Readonly<{ [k: string]: number | string }> = {};
// obj.hi = "ğŸ™Œ";
obj = { ...obj, hi: "ğŸ‘" };
```

### Things to Remember

- If your function does not modify its parameters, declare them readonly (arrays) or Readonly (object types). This makes the function's contract clearer and prevents inadvertent mutations in its implementation.
  - í•¨ìˆ˜ê°€ ë§¤ê°œë³€ìˆ˜ë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´? readonly array, Readonly objectë¥¼ ì ìš©í•´ ì˜ë„ì¹˜ ì•Šì€ ë³€ê²½ì„ ë°©ì§€
- Understand that readonly and Readonly are shallow, and that Readonly only affects properties, not methods.
  - ì–•ê²Œ ë™ì‘í•œë‹¤ & ë©”ì†Œë“œì—ëŠ” ì ìš©ë˜ì§€ ì•ŠìŒì„ ëª…ì‹¬
- Use readonly to prevent errors with mutation and to find the places in your code where mutations occur.
  - readonlyë¥¼ ì‚¬ìš©í•´ì„œ, ë³€ê²½í•˜ë©´ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ ë°©ì§€í•˜ê³  ë³€ê²½ì´ ë°œìƒí•˜ëŠ” ì½”ë“œ ì‰½ê²Œ ì°¾ê¸°
- Understand the difference between const and readonly: the former prevents reassignment, the latter prevents mutation.
  - constì™€ readonly ì°¨ì´ì  => constëŠ” ì¬í• ë‹¹x. readonlyëŠ” ë³€ê²½ì„ ë°©ì§€ (ì¬í• ë‹¹... ëœë‹¤...)

---

## ì•„ì´í…œ 18: ë§¤í•‘ëœ íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ê°’ì„ ë™ê¸°í™”í•˜ê¸° Use Record Types to Keep Values in Sync

> ì˜ë¬¸ ì„œì ì—ì„œëŠ” Item 61

### (fail closed) ë³´ìˆ˜ì  ì ‘ê·¼ë²• Conservative Approachì„ í†µí•´ ê°’ ë³€ê²½

- propsì˜ ëª¨ë“  ì†ì„±ì„ ê²€ì‚¬í•˜ì—¬ ë³€ê²½ì´ ìˆëŠ”ì§€ í™•ì¸
- onClick ì†ì„±ì„ ì œì™¸í•œ ëª¨ë“  ì†ì„±ì˜ ë³€ê²½ì„ ê°ì§€í•˜ëŠ” ì ‘ê·¼ë²•

```tsx
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  for (const kStr in oldProps) {
    const k = kStr as keyof ScatterProps;
    if (oldProps[k] !== newProps[k]) {
      if (k !== "onClick") return true;
    }
  }
  return false;
}
```

### (fail open) ì‹¤íŒ¨ì— ì—´ë¦° ì ‘ê·¼ë²•ì„ í†µí•´ ê°’ ë³€ê²½

- íŠ¹ì • ì†ì„±ë§Œ ê²€ì‚¬í•˜ì—¬ ê°’ì„ ë³€ê²½í•˜ëŠ” ë°©ë²•
- ëª¨ë“  ì†ì„±ì„ ê²€ì‚¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì˜ˆìƒì¹˜ ëª»í•œ ë³€ê²½ì´ ë°œìƒí•˜ê±°ë‚˜, ë³€ê²½ì´ ë°œìƒí•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ ("first, do no harm" ì›ì¹™ì— ìœ„ë°°)

```tsx
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  return (
    oldProps.xs !== newProps.xs ||
    oldProps.ys !== newProps.ys ||
    oldProps.xRange !== newProps.xRange ||
    oldProps.yRange !== newProps.yRange ||
    oldProps.color !== newProps.color
    // (no check for onClick)
  );
}
```

### ìƒˆë¡œìš´ ì†ì„±ì´ ì¶”ê°€ë  ë•Œ ê°’ ë³€ê²½

- ë³´ìˆ˜ì  ì ‘ê·¼ë²•ê³¼ ìœ ì‚¬í•˜ì§€ë§Œ, íƒ€ì… ì²´ì»¤ë¥¼ í™œìš©í•˜ì—¬ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì´ë¥¼ ê°•ì œí•˜ë„ë¡ í•¨
  - ë§¤í•‘ëœ íƒ€ì… `REQUIRES_UPDATE` ê°ì²´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì–´ë–¤ ì†ì„±ì´ ë³€ê²½ë  ë•Œ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•œì§€ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜
- ìƒˆë¡œìš´ ì†ì„±ì´ ì¶”ê°€ë  ë•Œ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë˜ë¯€ë¡œ í™•ì¥ì„±ì´ ë†’ìŒ

```tsx
const REQUIRES_UPDATE: Record<keyof ScatterProps, boolean> = {
  xs: true,
  ys: true,
  xRange: true,
  yRange: true,
  color: true,
  onClick: false,
};

function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  for (const kStr in oldProps) {
    const k = kStr as keyof ScatterProps;
    if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {
      // ë§¤í•‘ëœ íƒ€ì…ì„ í†µí•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì½”ë“œì— ì œì•½ì„ ê°•ì œí•˜ë„ë¡ í•¨
      return true;
    }
  }
  return false;
}
```

### Things to Remember

- Recognize the fail open versus fail closed dilemma.
  - ê° ì ‘ê·¼ë²•ì— ëŒ€í•œ ë”œë ˆë§ˆ ì´í•´
- Use Record types to keep related values and types synchronized.
  - Record type, ë§¤í•‘ëœ íƒ€ì…ì„ ì‚¬ìš©í•´ ê°’ê³¼ íƒ€ì…ì„ ë™ê¸°í™”í•  ìˆ˜ ìˆë‹¤.
- Consider using Record types to force choices when adding new properties to an interface.
  - ì¸í„°í˜ì´ìŠ¤ì— ìƒˆë¡œìš´ ì†ì„±ì„ ì¶”ê°€í•  ë•Œ, Record typeì„ ì‚¬ìš©í•´ ì„ íƒì„ ê°•ì œí•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.

---

```
english
inadvertent [inÂ·adÂ·vertÂ·ent]: not resulting from or achieved through deliberate planning.
conservative [conÂ·servÂ·aÂ·tive] ë³´ìˆ˜ì 

```
