# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-05-17  
> ì‘ì„±ì: dusunax

## ì•„ì´í…œ 8 ì´ì–´ì„œ

> ì¤‘ê°„ ì €ì¥~!~!  
> 17ì¼ ëª©í‘œ: ~12ì¥ê¹Œì§€  
> ì´ í•™ìŠµì‹œê°„: í˜„ì¬ 1ì‹œê°„ 50ë¶„

### ì†ì„± ì ‘ê·¼ì [], property accessor

- obj['field']ì™€ obj.fieldëŠ” ê°’ì´ ë™ì¼í•˜ë”ë¼ë„ íƒ€ì…ì€ ë‹¤ë¥¼ ìˆ˜ ìˆë‹¤.

```tsx
const jane: Person = { first: "Jane", last: "Jacobs" };
const first: Person["first"] = jane["first"]; // Or jane.first
//    â€•â€•â€•â€•â€•                    â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€• Values. "Jane"
//           â€•â€•â€•â€•â€•â€• â€•â€•â€•â€•â€•â€•â€•                  Types, íƒ€ì… ë§¥ë½ì—ì„œ ì“°ì˜€ê¸° ë•Œë¬¸ì— íƒ€ì…
```

- íƒ€ì…ì˜ ì†ì„±ì„ ì–»ì„ ë•ŒëŠ”, `[]`ë¥¼ ì‚¬ìš©í•œë‹¤.

  - type.fieldë¡œ ì ‘ê·¼í•  ìˆ˜ ì—†ìŒ

    > Cannot access 'Person.first' because 'Person' is a type, but not a namespace. Did you mean to retrieve the type of the property 'first' in 'Person' with 'Person["first"]'?
    > ![image](https://github.com/dusunax/blog/assets/94776135/c2bcff80-a404-4854-b480-b7a1c7a5cb43)

  - Person í´ë˜ìŠ¤ë¥¼ íƒ€ì…(type)ìœ¼ë¡œ ì‚¬ìš©í•  ê²ƒì´ê¸° ë•Œë¬¸ì—, ë„¤ì„ìŠ¤í˜ì´ìŠ¤ì²˜ëŸ¼ ì†ì„±ì— ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤.

    - í´ë˜ìŠ¤: íŠ¹ì • ê°ì²´ë¥¼ ìƒì„±í•˜ê¸° ìœ„í•œ blueprint
    - ë„¤ì„ìŠ¤í˜ì´ìŠ¤: ì½”ë“œë¥¼ ë…¼ë¦¬ì ìœ¼ë¡œ ê·¸ë£¹í™”í•˜ê³ , ì „ì—­ ìŠ¤ì½”í”„ì˜ ì˜¤ì—¼ì„ ë°©ì§€ (ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë¥¼ í†µí•´ í•¨ìˆ˜, í´ë˜ìŠ¤, ë³€ìˆ˜ ë“±ì— ì ‘ê·¼)

- ì¸ë±ìŠ¤ì—ëŠ” union, ê¸°ë³¸í˜• (js íƒ€ì…)ì„ í¬í•¨í•´ ì–´ë–¤ íƒ€ì…ì´ë“  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

```tsx
type PersonEl = Person["first" | "last"]; // union!
//   ^? type PersonEl = string
type Tuple = [string, number, Date]; // ê¸°ë³¸í˜•
type TupleEl = Tuple[number];
//   ^? type TupleEl = string | number | Date
```

### Value vs Type ğŸ¤”

#### ğŸ“Œ this

|           | this                |
| --------- | ------------------- |
| ê°’ value  | ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ this |
| íƒ€ì… type | ë‹¤í˜•ì„± this         |

- valueë¡œ ì“°ì´ëŠ” thisëŠ”? JSì˜ thisë‹¤.
- typeìœ¼ë¡œ ì“°ì´ëŠ” thisëŠ”? ë‹¤í˜•ì„± this(polymorphic this)ë‹¤.
  > polymorphic thisëŠ”? ìë°”ìŠ¤í¬ë¦½íŠ¸ì™€ ë§ˆì°¬ê°€ì§€ë¡œ í˜„ì¬ ì‹¤í–‰ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì°¸ì¡°í•©ë‹ˆë‹¤.  
  > ì—¬ëŸ¬ í´ë˜ìŠ¤ë‚˜ ê°ì²´ì—ì„œ ê³µí†µëœ ë©”ì„œë“œë¥¼ ì •ì˜í•˜ë©´ì„œë„ ê°ê¸° ë‹¤ë¥¸ ë™ì‘ì„ êµ¬í˜„í•  ìˆ˜ ìˆëŠ”ë°,  
  > ì£¼ë¡œ ìƒì†ê³¼ ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ êµ¬í˜„ë©ë‹ˆë‹¤. ìœ ì—°ì„±ì„ í™œìš©!

#### ğŸ“Œ polymorphic this

- í´ë˜ìŠ¤ì™€ ìƒì†, ì˜¤ë²„ë¼ì´ë”©

```tsx
class Animal {
  move(distance: number) {
    console.log(`${this.constructor.name} moved ${distance} meters.`);
    // thisëŠ” ë©”ì„œë“œë¥¼ í˜¸ì¶œí•œ ê°ì²´ì´ë‹¤
  }
}

class Dog extends Animal {
  move(distance: number) {
    console.log("Dog is running...");
    super.move(distance);
  }
}

class Bird extends Animal {
  move(distance: number) {
    console.log("Bird is flying...");
    super.move(distance);
  }
}

const dog = new Dog();
dog.move(10); // Dog is running... Dog moved 10 meters.

const bird = new Bird();
bird.move(20); // Bird is flying... Bird moved 20 meters.
```

- ì¸í„°í˜ì´ìŠ¤, ë©”ì„œë“œ ì²´ì´ë‹

```tsx
interface Movable {
  move(distance: number): this;
}

class Car implements Movable {
  move(distance: number): this {
    console.log(`Car drove ${distance} kilometers.`);
    return this;
  }

  refuel(amount: number): this {
    console.log(`Car refueled with ${amount} liters.`);
    return this;
  }
}

class Plane implements Movable {
  move(distance: number): this {
    console.log(`Plane flew ${distance} miles.`);
    return this;
  }

  maintain(): this {
    console.log("Plane underwent maintenance.");
    return this;
  }
}

const car = new Car();
const plane = new Plane();

car.move(100).refuel(50);
// Output:
// Car drove 100 kilometers.
// Car refueled with 50 liters.

plane.move(1000).maintain();
// Output:
// Plane flew 1000 miles.
// Plane underwent maintenance.
```

#### ğŸ“Œ &ì™€ |

|           | &            | &#124; |
| --------- | ------------ | ------ |
| ê°’ value  | AND          | OR     |
| íƒ€ì… type | intersection | union  |

#### ğŸ“Œ const

|           | const                                       |
| --------- | ------------------------------------------- |
| ê°’ value  | const ìƒˆ ë³€ìˆ˜ ì„ ì–¸                          |
| íƒ€ì… type | as const ë¦¬í„°ëŸ´ í‘œí˜„ì‹ì˜ ì¶”ë¡ ëœ íƒ€ì…ì„ ë°”ê¿ˆ |

#### ğŸ“Œ extends

- ì„œë¸Œí´ë˜ìŠ¤ ë˜ëŠ” ì„œë¸Œíƒ€ì…, ì œë„¤ë¦­ íƒ€ì…ì˜ í•œì •ìë¥¼ ì •ì˜í•  ìˆ˜ ìˆë‹¤.
- ì„œë¸Œí´ë˜ìŠ¤

```tsx
class Animal {
  move() {
    console.log("Moving along!");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Woof! Woof!");
  }
}
```

- ì„œë¸Œíƒ€ì…

```tsx
interface Person {
  name: string;
  age: number;
}

interface Employee extends Person {
  employeeId: number;
}

const employee: Employee = {
  name: "John",
  age: 30,
  employeeId: 1234,
};
```

- ì œë„¤ë¦­ì˜ í•œì •ì

```tsx
function logLength<T extends { length: number }>(item: T): void {
  console.log(item.length);
}

logLength("Hello, TypeScript!"); // 18
logLength([1, 2, 3, 4, 5]); // 5

logLength(123); // Error: Argument of type 'number' is not assignable to parameter of type '{ length: number; }'.
```

#### ğŸ“Œ in

- loop ë˜ëŠ” mapped íƒ€ì…ì— ë“±ì¥

##### loop

- ë°˜ë³µë¬¸ì—ì„œ ê°ì²´ì˜ ì†ì„±ì„ ìˆœíšŒí•  ë•Œ ì‚¬ìš©ë©ë‹ˆë‹¤. ì£¼ë¡œ for...in ë£¨í”„ì™€ í•¨ê»˜ ì‚¬ìš©ë˜ë©°, ê°ì²´ì˜ ê° ì†ì„±ì„ ë°˜ë³µí•˜ë©´ì„œ ì‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.

  ```tsx
  const obj = { a: 1, b: 2, c: 3 };

  for (const key in obj) {
    console.log(`${key}: ${obj[key]}`);
  }
  // ì¶œë ¥:
  // a: 1
  // b: 2
  // c: 3
  ```

##### mapped

- Mapped íƒ€ì…ì—ì„œ in ì—°ì‚°ìëŠ” ì¡°ê±´ë¶€ íƒ€ì…ê³¼ í•¨ê»˜ ì‚¬ìš©ë  ë•Œ íƒ€ì… ë³€í™˜ì„ ìˆ˜í–‰í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤ (ê°ì²´ì˜ ëª¨ë“  ì†ì„±ì„ ë°˜ë³µí•˜ë©´ì„œ ìƒˆë¡œìš´ íƒ€ì…ì„ ë§Œë“¤ê±°ë‚˜ ìˆ˜ì •í•˜ëŠ” ë° ì‚¬ìš©)

  ```tsx
  type Optional<T> = {
    [K in keyof T]?: T[K];
    // in ì—°ì‚°ìëŠ” keyof Të¥¼ í†µí•´ Personì˜ ëª¨ë“  ì†ì„±ì„ ë°˜ë³µ
    // ê° ì†ì„±ì— ëŒ€í•´ ?:ë¥¼ ì‚¬ìš©í•˜ì—¬ ì˜µì…”ë„
  };

  interface Person {
    name: string;
    age: number;
  }

  type OptionalPerson = Optional<Person>;
  // { name?: string; age?: number; }
  ```

#### íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì˜ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´?

- type space íƒ€ì… ê³µê°„ê³¼ value spaceë¥¼ í˜¼ë™í•´ì„œ ì˜ëª» ì‘ì„±í–ˆì„ ê°€ëŠ¥ì„±ì´ í¬ë‹¤.

```tsx
function email({
  to: Person; // ê°’ì˜ ê´€ì ì— í•´ì„ë˜ì—ˆê¸° ë•Œë¬¸ì— ì—ëŸ¬!
  subject: string;
  body: string;
}) {
  // ...
}

// ê°’ê³¼ íƒ€ì…ì„ êµ¬ë¶„í•˜ëŠ” ì´ìœ 
function email(
  {to, subject, body}: // ê°’
  {to: Person, subject: string, body: string} // íƒ€ì…
) {
  // ...
}
```

![image](https://github.com/dusunax/blog/assets/94776135/d1fffd96-cdcd-4590-b684-c2db79621635)

### Things to Remember

- Know how to tell whether you're in type space or value space while reading a TypeScript expression. Use the TypeScript playground to build an intuition for this.
  - íƒ€ì… ê³µê°„ê³¼ ê°’ ê³µê°„ì„ êµ¬ë¶„í•˜ëŠ” ë°©ë²•ì„ í„°ë“í•´ì•¼í•¨
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ í”Œë ˆì´ê·¸ë¼ìš´ë“œ https://www.typescriptlang.org/play/?#code/
- Every value has a static type, but this is only accessible in type space. Type space constructs such as type and interface are erased and are not accessible in value space.
  - ëª¨ë“  ê°’ì€ íƒ€ì…ì„ ê°€ì§€ì§€ë§Œ, ì´ íƒ€ì…ì€ íƒ€ì… ê³µê°„ì—ì„œë§Œ ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
  - íƒ€ì… ê³µê°„ì—ì„œ ë§Œë“  íƒ€ì…, ì¸í„°í˜ì´ìŠ¤ëŠ” ê°’ ê³µê°„ì—ì„œëŠ” ì‚­ì œëœë‹¤.
    - typeê³¼ interfaceëŠ” type spaceì— ì¡´ì¬
- Some constructs, such as class or enum, introduce both a type and a value.
  - classì™€ enumì€ íƒ€ì…ê³¼ ê°’ìœ¼ë¡œ ë‘˜ ë‹¤ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤
- typeof, this, and many other operators and keywords have different meanings in type space and value space.
  - typeof, this ë“±ì˜ ë§ì€ ì—°ì‚°ìì™€ í‚¤ì›Œë“œëŠ” => type spaceì™€ value spaceì—ì„œ ë‹¤ë¥¸ ëª©ì ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤

## ì•„ì´í…œ 9 íƒ€ì… ë‹¨ì–¸ë³´ë‹¤ëŠ” íƒ€ì… ì„ ì–¸ì„ ì‚¬ìš©í•˜ê¸° Prefer Type Annotations to Type Assertions

- ì™œ? íƒ€ì… ë‹¨ì–¸ì€ íƒ€ì… ì²´ì»¤ì—ê²Œ ì˜¤ë¥˜ë¥¼ ë¬´ì‹œí•˜ë¼ê³  í•˜ëŠ” ê²ƒì´ê¸° ë•Œë¬¸ì´ë‹¤

```tsx
interface Person {
  name: string;
}

// Type Annotationsì€ í• ë‹¹ëœ ê°’ì´ í•´ë‹¹ ì¸í„°í˜ì´ìŠ¤ë¥¼ ë§Œì¡±í•˜ëŠ”ì§€
const alice: Person = { name: "Alice" };
//    ^? const alice: Person

// Type AssertionsëŠ” ì¶”ë¡ í•œ íƒ€ì…ì´ ìˆë”ë¼ë„, í•´ë‹¹ íƒ€ì…ìœ¼ë¡œ ê°„ì£¼í•œë‹¤
const bob = { name: "Bob" } as Person; // Type Assertions
//    ^? const bob: Person
```

#### ì‰ì—¬ ì†ì„± ì²´í¬ excess property checkingë„ ì ìš©ë˜ì§€ ì•ŠìŒ

```tsx
const alice: Person = {
  name: "Alice",
  occupation: "TypeScript developer",
  // ~~~~~~~~~ Object literal may only specify known properties,
  //           and 'occupation' does not exist in type 'Person'
};
const bob = {
  name: "Bob",
  occupation: "JavaScript developer",
} as Person; // ì—ëŸ¬ê°€ ì—†ìŒ!
```

#### ì´ì „ì— íƒ€ì… ë‹¨ì–¸ì„ ì‚¬ìš©í•˜ë˜ ì½”ë“œ í˜•íƒœ

```tsx
const bob = <Person>{};
```

- í˜„ì¬ëŠ” tsxì˜ ì»´í¬ë„ŒíŠ¸ íƒœê·¸ë¡œ ì¸ì‹ë˜ê¸° ë•Œë¬¸ì— ì“°ì´ì§€ ì•ŠëŠ”ë‹¤.
  ![image](https://github.com/dusunax/blog/assets/94776135/980c2a71-9094-4040-94d9-3da12431e479)

#### í™”ì‚´í‘œ í•¨ìˆ˜

- ìµœì¢…ì ìœ¼ë¡œ ì›í•˜ëŠ” íƒ€ì…ì„ ì§ì ‘ ëª…ì‹œí•˜ê³ , íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ í• ë‹¹ë¬¸ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ë„ë¡ í•¨
- ë‹¨, í•¨ìˆ˜ í˜¸ì¶œ ì²´ì´ë‹ì´ ì—°ì†ë˜ëŠ” ê³³ì€, ì²´ì´ë‹ ì‹œì‘ë¶€í„° ëª…ëª…ëœ íƒ€ì…ì„ ê°€ì ¸ì•¼ í•œë‹¤
  (ì •í™•í•œ ê³³ì— ì˜¤ë¥˜ í‘œê¸°í•˜ê¸° ìœ„í•¨)

```tsx
interface Person {
  name: string;
}
// íƒ€ì… ë‹¨ì–¸
const people = ["alice", "bob", "jan"].map((name) => ({ name } as Person)); // Type is Person[]

// ë‹¨ì–¸ ì‹œ ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°œìƒ
const wrongPeople = ["alice", "bob", "jan"].map((name) => ({} as Person)); // Type is Person[]

// ìµœì¢…ì ìœ¼ë¡œ ì›í•˜ëŠ” íƒ€ì…ì„ ì§ì ‘ ëª…ì‹œí•˜ê³ , íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ í• ë‹¹ë¬¸ì˜ ìœ íš¨ì„±ì„ ê²€ì‚¬í•˜ë„ë¡ í•¨
const goodPeople: Person[] = ["alice", "bob", "jan"].map((name) => ({ name })); // OK
```

#### Type Assertionì´ í•„ìš”í•œ ê²½ìš°

- íƒ€ì… ì²´ì»¤ê°€ ì¶”ë¡ í•œ íƒ€ì…ë³´ë‹¤, ê°œë°œìê°€ íŒë‹¨í•œ íƒ€ì…ì´ ë” ì •í™•í•  ë•Œ
  - ex) DOM element

```tsx
document.querySelector("#myButton")?.addEventListener("click", (e) => {
  e.currentTarget;
  // ^? (property) Event.currentTarget: EventTarget | null
  // currentTarget is #myButton is a button element: íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì•Œì§€ ëª»í•˜ëŠ” ì •ë³´, why? DOMì— ì ‘ê·¼í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—
  const button = e.currentTarget as HTMLButtonElement;
  //    ^? const button: HTMLButtonElement
});
```

#### nonNullAssertion: !

- ë³€ìˆ˜ì˜ ì ‘ë‘ì‚¬ë¡œ ì“°ì¸ !ëŠ”? booleanì˜ ë¶€ì •ë¬¸
- ì ‘ë¯¸ì‚¬ë¡œ ì“°ì¸ !ëŠ”? ê·¸ ê°’ì´ Nullì´ ì•„ë‹ˆë¼ëŠ” ë‹¨ì–¸ë¬¸ìœ¼ë¡œ í•´ì„ëœë‹¤.
- ì£¼ì˜
  - ë‹¨ì–¸ë¬¸ì€ ì»´íŒŒì¼ ê³¼ì •ì—ì„œ ì œê±°ëœë‹¤.
  - íƒ€ì… ì²´ì»¤ëŠ” ì•Œì§€ ëª»í•˜ì§€ë§Œ, ê°’ì´ nullì´ ì•„ë‹˜ì„ í™•ì‹ í•  ìˆ˜ ìˆì„ ë•Œ ì‚¬ìš©í•œë‹¤
    - í™•ì‹ í•  ìˆ˜ ì—†ë‹¤ë©´ ì¡°ê±´ë¬¸ìœ¼ë¡œ null ì²´í¬ í•´ì•¼í•œë‹¤.

#### íƒ€ì… ë‹¨ì–¸ì„ ì‚¬ìš©í•œ íƒ€ì… ë³€í™˜ê³¼ unknown

```tsx
interface Person {
  name: string;
}
const body = document.body;
const el = body as Person;
//         ~~~~~~~~~~~~~~
// Conversion of type 'HTMLElement' to type 'Person' may be a mistake because
// neither type sufficiently overlaps with the other. If this was intentional,
// convert the expression to 'unknown' first.
```

![image](https://github.com/dusunax/blog/assets/94776135/bf07b55b-0083-46a3-ba22-5ce0ee315e6b)

- ì„œë¡œì˜ ì„œë¸Œ íƒ€ì…ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ë³€í™˜ì´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.

  - ë§Œì•½ unknown íƒ€ì…ì„ ì‚¬ìš©í•´ ì„ì˜ì˜ íƒ€ì… ê°„ì˜ ë³€í™˜ì´ ê°€ëŠ¥í•œ, í•­ìƒ ë™ì‘í•˜ëŠ” ë‹¨ì–¸ì„ ì‚¬ìš©í•˜ëŠ” ê²½ìš°? ë¬´ì–¸ê°€ ìœ„í—˜í•œ ë™ì‘ì„ í•˜ê³  ìˆìŒì„ ì•Œ ìˆ˜ ìˆìŒ
  - ëª¨ë“  íƒ€ì…ì€ unknownì˜ ì„œë¸Œíƒ€ì…ì´ê¸° ë•Œë¬¸ì—, unknown ë‹¨ì–¸ì€ í•­ìƒ ë™ì‘í•œë‹¤

    ```tsx
    const el = document.body as unknown as Person; // OK
    ```

### Things to Remember

- Prefer type annotations (: Type) to type assertions (as Type).
  - ë‹¨ì–¸ë³´ë‹¤ ì„ ì–¸ì„ ì‚¬ìš©í•˜ì
- Know how to annotate the return type of an arrow function.
  - í™”ì‚´í‘œ í•¨ìˆ˜ì˜ ë°˜í™˜ íƒ€ì… ëª…ì‹œí•˜ëŠ” ë²• ì•Œê¸°
- Use type assertions and non-null assertions only when you know something about types that TypeScript does not.
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ë³´ë‹¤ ë” ì˜ ì•Œê³  ìˆëŠ” ê²Œ í™•ì‹¤í•œ ìƒí™©ì—ì„œë§Œ íƒ€ì… ë‹¨ì–¸ê³¼ non-null ë‹¨ì–¸ì„ ì“°ì.
- When you use a type assertion, include a comment explaining why it's valid. // ì¢‹ì€ í˜‘ì—… ìŠµê´€

---

```
// English
mnemonic [mneÂ·monÂ·ic] ì—°ìƒ ê¸°í˜¸
intuition [inÂ·tuÂ·iÂ·tion] the ability to understand something immediately, without the need for conscious reasoning.
exclamation mark [exÂ·claÂ·maÂ·tion mark] !
```
