# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-05-22  
> ì‘ì„±ì: dusunax

---

## ì•„ì´í…œ 20: ë‹¤ë¥¸ íƒ€ì…ì—ëŠ” ë‹¤ë¥¸ ë³€ìˆ˜ ì‚¬ìš©í•˜ê¸° Use Different Variables for Different Types

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ "ë³€ìˆ˜ì˜ ê°’ì€ ë°”ë€” ìˆ˜ ìˆì§€ë§Œ ê·¸ íƒ€ì…ì€ ë³´í†µ ë°”ë€Œì§€ ì•ŠëŠ”ë‹¤"
- íƒ€ì…ì„ ë°”ê¾¸ëŠ” ë²•
  - type narrowing: íƒ€ì…ì„ "ì¢íŒë‹¤"

### ë‹¤ë¥¸ íƒ€ì…ì—ëŠ” ë³„ë„ì˜ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²Œ ë°”ëŒì§

```tsx
let productId: string | number = "12-34-56";
fetchProduct(productId);

// íƒ€ì…ì„ ì¢í˜€ì„œ ë‹¤ë¥¸ íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
productId = 123456; // OK
fetchProductBySerialNumber(productId); // OK

// ë‹¤ë¥¸ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤

// ì§€ì—­ ìŠ¤ì½”í”„
```

- ì¥ì 
  - ì„œë¡œ ê´€ë ¨ì´ ì—†ëŠ” ë‘ ê°œì˜ ê°’ì„ ë¶„ë¦¬
  - ë³€ìˆ˜ëª…ì„ ë” êµ¬ì²´ì ìœ¼ë¡œ ì§€ì„ ìˆ˜ ìˆìŒ
  - íƒ€ì… ì¶”ë¡ ì„ í–¥ìƒì‹œí‚¤ë©°, ë¶ˆí•„ìš”í•œ íƒ€ì… êµ¬ë¬¸x
  - íƒ€ì…ì´ ê°„ê²°í•´ì§ (ìœ ë‹ˆì˜¨ì„ ì•ˆ ì“¸ ìˆ˜ ìˆë‹¤)
  - let ëŒ€ì‹  constë¡œ ì„ ì–¸í•˜ì—¬, ê°„ê²°í•˜ê³  íƒ€ì…ì„ ì¶”ë¡ í•˜ê¸° ì‰¬ìš´ ì½”ë“œ ì‘ì„±
- ê²°ë¡ 
  - íƒ€ì…ì´ ë°”ë€ŒëŠ” ë³€ìˆ˜ë¥¼ í”¼í•˜ì
  - ëª©ì ì´ ë‹¤ë¥¸ ê³³ì—ëŠ” ë³„ë„ì˜ ë³€ìˆ˜ëª…ì„ ì‚¬ìš©í•˜ì

### shadowed ë³€ìˆ˜

```tsx
let x = 10;

function example() {
  // ì§€ì—­ ìŠ¤ì½”í”„
  let x = 20; // This 'x' shadows the outer 'x'
  console.log(x); // 20
}

example();
console.log(x); // 10
```

### Things to Remember

- While a variable's value can change, its type generally does not.
  - ë³€ìˆ˜ì˜ ê°’ì€ ë°”ë€Œì§€ë§Œ, ì¼ë°˜ì ìœ¼ë¡œ íƒ€ì…ì€ ë°”ë€Œì§€ ì•ŠëŠ”ë‹¤
- To avoid confusion, both for human readers and for the type checker, avoid reusing variables for differently typed values.
  - í˜¼ë€ì„ ë§‰ê¸° ìœ„í•´, íƒ€ì…ì´ ë‹¤ë¥¸ ê°’ì„ ë‹¤ë£° ë•ŒëŠ” ë³€ìˆ˜ë¥¼ ì¬ì‚¬ìš©í•˜ì§€ ì•Šê¸°

## ì•„ì´í…œ 21: íƒ€ì… ë„“íˆê¸° Understand How a Variable Gets Its Type

- ëŸ°íƒ€ì„ì— ëª¨ë“  ë³€ìˆ˜ëŠ” ìœ ì¼í•œ ê°’ì„ ê°€ì§„ë‹¤
- ì •ì  ë¶„ì„ ì‹œì (íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì‘ì„±ëœ ì½”ë“œë¥¼ ì²´í¬í•˜ëŠ” ì‹œì )ì— ë³€ìˆ˜ëŠ” `ê°€ëŠ¥í•œ ê°’ë“¤ì˜ ì§‘í•©`ì¸ íƒ€ì…ì„ ê°€ì§„ë‹¤

### Type Widening

- ìƒìˆ˜ë¡œ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•´ì„œ íƒ€ì…ì„ ëª…ì‹œí•˜ì§€ ì•Šìœ¼ë©´, íƒ€ì… ì²´ì»¤ê°€ íƒ€ì…ì„ ê²°ì •í•´ì•¼ í•œë‹¤.

  - ì§€ì •ëœ ë‹¨ì¼ ê°’ë“¤ì„ ê°€ì§€ê³ , í• ë‹¹ ê°€ëŠ¥í•œ ê°’ë“¤ì˜ ì§‘í•©ì„ ìœ ì¶”í•œë‹¤
    - ì •ë³´ê°€ ì¶©ë¶„í•˜ì§€ ì•Šìœ¼ë©´, ì–´ë–¤ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë˜ì–´ì•¼í•˜ëŠ” ì§€ ì•Œ ìˆ˜ ì—†ë‹¤ (ì‘ì„±ìì˜ ì˜ë„ë¥¼ ì¶”ì¸¡í•œë‹¤)

  ```tsx
  interface Vector3 {
    x: number;
    y: number;
    z: number;
  }
  function getComponent(vector: Vector3, axis: "x" | "y" | "z") {
    return vector[axis];
  }

  let x = "x"; // constë¡œ ì„ ì–¸í•  ì‹œ "x" ìœ ë‹› íƒ€ì…
  let vec = { x: 10, y: 20, z: 30 };
  getComponent(vec, x);
  //                ~ Argument of type 'string' is not assignable
  //                  to parameter of type '"x" | "y" | "z"'
  ```

### Type wideningì„ ì œì–´í•  ìˆ˜ ìˆëŠ” ë°©ë²•

- TypeScriptì—ì„œ íƒ€ì…ì„ ë” ì¢ì€ ë²”ìœ„ë¡œ ì¶”ë¡ í•˜ë„ë¡ ì œì–´í•˜ëŠ” ë°©ë²•ì—ëŠ” ì—¬ëŸ¬ ê°€ì§€ê°€ ìˆìŒ
- ë³€ìˆ˜ë‚˜ ìƒìˆ˜ì˜ íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì§€ì •í•˜ê±°ë‚˜, íƒ€ì… ì²´ì»¤ì— ì¶”ê°€ì ì¸ ì •ë³´ë¥¼ ì œê³µí•˜ì—¬ ê°€ëŠ¥í•œ í•œ ì¢ì€ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•˜ê²Œ í•¨

#### 1. constë¡œ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë©´ ë” ì¢ì€ íƒ€ì…ì´ ëœë‹¤

- constë¥¼ ì‚¬ìš©í•˜ë©´ ë³€ìˆ˜ëŠ” ì¬í• ë‹¹ì´ ë¶ˆê°€ëŠ¥í•´ì§€ë¯€ë¡œ ë” ì¢ì€ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ 
- ê·¸ëŸ¬ë‚˜ ê°ì²´ì™€ ë°°ì—´ì˜ ê²½ìš°, ë‚´ë¶€ ìš”ì†Œë“¤ì€ ì—¬ì „íˆ ë„“ì€ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ ë  ìˆ˜ ìˆìŒ
- ë‹¤ë¥¸ ì†ì„± ì¶”ê°€í•  ìˆ˜ ì—†ì–´ ê°ì²´ë¥¼ í•œ ë²ˆì— ë§Œë“¤ì–´ì•¼ í•¨(ì•„ì´í…œ 23)

#### 2. íƒ€ì… ì²´ì»¤ì— ì¶”ê°€ì ì¸ ë¬¸ë§¥ì„ ì œê³µ (í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ë¡œ ê°’ ì „ë‹¬ ë“±)

```tsx
function processPoint(point: { x: 10; y: 20 }) {
  // processPoint ë‚´ë¶€ì—ì„œëŠ” pointì˜ íƒ€ì…ì´ { x: 10, y: 20 }ë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤.
}
const p = { x: 10, y: 20 };
processPoint(p);
```

#### 3. const ë‹¨ì–¸ë¬¸ì„ ì‚¬ìš© (as const)

- ê°’ ë’¤ì— as constë¥¼ ì‘ì„±í•˜ë©´, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ìµœëŒ€í•œ ì¢ì€ íƒ€ì…ìœ¼ë¡œ ì¶”ë¡ í•©ë‹ˆë‹¤.

```tsx
const point = { x: 10, y: 20 } as const; // Type is { readonly x: 10, readonly y: 20 }
```

#### 4.satisfies í‚¤ì›Œë“œë¥¼ ì‚¬ìš©

- satisfies í‚¤ì›Œë“œëŠ” capitalsBad ê°ì²´ê°€ `Record<string, Point>`` íƒ€ì…ì„ ë§Œì¡±í•˜ëŠ”ì§€ í™•ì¸
- ì´ ê²½ìš°, ê° ì†ì„±ì˜ ê°’ì´ Point íƒ€ì…(ì¦‰, [number, number])ì„ ì¶©ì¡±í•˜ì§€ ì•Šìœ¼ë©´ ì˜¤ë¥˜ ë°œìƒ
- íŠ¹ì§•
  - satisfies í‚¤ì›Œë“œëŠ” íƒ€ì… í™•ì¸ì„ ìˆ˜í–‰í•˜ì§€ë§Œ, ë³€ìˆ˜ì˜ ì›ë˜ íƒ€ì…ì„ ë³€ê²½í•˜ì§€ ì•ŠìŒ
  - asì™€ ë‹¬ë¦¬, satisfiesëŠ” íƒ€ì… ë‹¨ì–¸ì„ í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ íƒ€ì… ì•ˆì „ì„±ì„ ìœ ì§€

```tsx
type Point = [number, number];
const capitalsBad = {
  ny: [-73.7562, 42.6526, 148],
  //  ~~ Type '[number, number, number]' is not assignable to type 'Point'.
  ca: [-121.4944, 38.5816, 26],
  //  ~~ Type '[number, number, number]' is not assignable to type 'Point'.
} satisfies Record<string, Point>;
```

### Things to Remember

- Understand how TypeScript infers a type from a literal by widening it.
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ë¦¬í„°ëŸ´ì—ì„œ ì–´ë–»ê²Œ íƒ€ì…ì„ ë„“íˆëŠ” ì§€ ì´í•´í•˜ê¸°
- Familiarize yourself with the ways you can affect this behavior: const, type annotations, context, helper functions, as const, and satisfies.
  - ë™ì‘ì— ì˜í–¥ì„ ì¤„ ìˆ˜ ìˆëŠ” ë°©ë²•ë“¤:

## ì•„ì´í…œ 22: íƒ€ì… ì¢íˆê¸° Understand Type Narrowing

### null ì²´í¬í•˜ê¸°

```tsx
const elem = document.getElementById("what-time-is-it");
//    ^? const elem: HTMLElement | null
if (!elem) throw new Error("Unable to find #what-time-is-it"); // nullì„ ì²´í¬í•¨
elem.innerHTML = "Party Time".blink();
// ^? const elem: HTMLElement
```

### Type narrowing íƒ€ì… ì¢íˆê¸° ì˜ˆì‹œ

```tsx
// [ë¶„ê¸°ë¬¸] ê°’ì˜ íƒ€ì…ì„ instacneofë¥¼ ì‚¬ìš©í•˜ì—¬ ì¢í˜
function contains(text: string, search: string | RegExp) {
  if (search instanceof RegExp) {
    return !!search.exec(text);
    //       ^? (parameter) search: RegExp
  }
  return text.includes(search);
  //                   ^? (parameter) search: string
}

// [ì†ì„± ì²´í¬] ì†ì„±ì˜ ì¡´ì¬ ì—¬ë¶€ë¡œ interface íƒ€ì… ì¢íˆê¸°
interface Apple {
  isGoodForBaking: boolean;
}
interface Orange {
  numSlices: number;
}
function pickFruit(fruit: Apple | Orange) {
  if ("isGoodForBaking" in fruit) {
    fruit;
    // ^? (parameter) fruit: Apple
  } else {
    fruit;
    // ^? (parameter) fruit: Orange
  }
  fruit;
  // ^? (parameter) fruit: Apple | Orange
}

// [ë‚´ì¥ í•¨ìˆ˜]
function contains(text: string, terms: string | string[]) {
  const termList = Array.isArray(terms) ? terms : [terms]; // ë‚´ì¥ ë©”ì†Œë“œë¡œ íƒ€ì… ì¢íˆê¸°
  //    ^? const termList: string[] ì´ì œ string ë°°ì—´
  // ...
}

// [tagged union] íƒœê·¸ëœ ìœ ë‹ˆì˜¨, ë˜ëŠ” êµ¬ë³„ëœ ìœ ë‹ˆì˜¨ discriminated union
interface UploadEvent {
  type: "upload"; // ìœ ë‹ˆì˜¨!
  filename: string;
  contents: string;
}
interface DownloadEvent {
  type: "download"; // ìœ ë‹ˆì˜¨!
  filename: string;
}
type AppEvent = UploadEvent | DownloadEvent;

function handleEvent(e: AppEvent) {
  switch (e.type) {
    case "download": // í™œìš©
      console.log("Download", e.filename);
      //                      ^? (parameter) e: DownloadEvent
      break;
    case "upload":
      console.log("Upload", e.filename, e.contents.length, "bytes");
      //                    ^? (parameter) e: UploadEvent
      break;
  }
}

// ì‚¬ìš©ì ì •ì˜ íƒ€ì… ê°€ë“œ
function isInputElement(el: Element): el is HTMLInputElement {
  return "value" in el;
}

function getElementContent(el: HTMLElement) {
  if (isInputElement(el)) {
    // ì¸í’‹ ì—˜ë¦¬ë¨¼íŠ¸ì´ëƒ?
    return el.value;
    //     ^? (parameter) el: HTMLInputElement
  }
  return el.textContent;
  //     ^? (parameter) el: HTMLElement
}

// ì»¤ìŠ¤í…€ íƒ€ì… ê°€ë“œ ì˜ˆì‹œ
function isDefined<T>(x: T | undefined): x is T {
  return x !== undefined;
}

const jackson5 = ["Jackie", "Tito", "Jermaine", "Marlon", "Micheal"];
const members = ["Janet", "Micheal"]
  .map((who) => jackson5.find((n) => n === who))
  .filter(isDefined); // filter(x => x !== undefined)ì€ ë°˜í™˜ë˜ëŠ” íƒ€ì…ì— ì˜í–¥ì„ ì£¼ì§€ ì•ŠìŒ
```

### ê¼¼ê¼¼íˆ ì‚´í”¼ê¸°

- nullì€ 'object'ì´ë‹¤.

  ```tsx
  const elem = document.getElementById("what-time-is-it");
  //    ^? const elem: HTMLElement | null
  if (typeof elem === "object") {
    elem;
    // ^? const elem: HTMLElement | null ğŸ¤·â€â™€ï¸
  }
  ```

- ""ì™€ 0ì€ ê°•ì œ ë³€í™˜ ì‹œ falseë‹¤.

  ```tsx
  function maybeLogX(x?: number | string | null) {
    if (!x) {
      console.log(x);
      //          ^? (parameter) x: string | number | null | undefined ğŸ¤·â€â™€ï¸
    }
  }
  ```

### Things to Remember

- Understand how TypeScript narrows types based on conditionals and other types of control flow.
  - ë¶„ê¸°ë¬¸ ì™¸ì—ë„ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ì œì–´ íë¦„ì„ ì‚´í´ë³´ë©°, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ íƒ€ì…ì„ ì¢íˆëŠ” ê³¼ì •ì„ ì´í•´í•˜ì
- Use tagged/discriminated unions and user-defined type guards to help the process of narrowing.
  - íƒ€ì… ì¢íˆê¸°ë¥¼ ë•íˆê¸° ìœ„í•´ `íƒœê·¸ëœ ìœ ë‹ˆì˜¨`ê³¼, `ì‚¬ìš©ì ì •ì˜ íƒ€ì… ê°€ë“œ`ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
- Think about whether code can be refactored to let TypeScript follow along more easily.
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì•Œê¸° ì‰¬ìš´ ì½”ë“œë¡œ ë¦¬íŒ©í† ë§í•˜ëŠ” ê²ƒì„ ê³ ë ¤

## ì•„ì´í…œ 23: í•œêº¼ë²ˆì— ê°ì²´ ìƒì„±í•˜ê¸° Create Objects All at Once

- ë³€ìˆ˜ì˜ ê°’ì€ ë³€ê²½o, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì˜ íƒ€ì…ì€ ì¼ë°˜ì ìœ¼ë¡œ ë³€ê²½x
  - ê°ì²´ë¥¼ ìƒì„±í•  ë•ŒëŠ” ì†ì„±ì„ í•˜ë‚˜ì”© ì¶”ê°€í•˜ê¸° ë³´ë‹¤ëŠ”, ì—¬ëŸ¬ ì†ì„±ì„ í¬í•¨í•˜ì—¬ í•œêº¼ë²ˆì— ìƒì„±í•´ì•¼ íƒ€ì… ì¶”ë¡ ì— ìœ ë¦¬í•©ë‹ˆë‹¤

```tsx
const pt = {}; // ë³€ìˆ˜ì˜ íƒ€ì…ì´ {} ê¸°ì¤€ìœ¼ë¡œ ì¶”ë¡ ë©ë‹ˆë‹¤.
//    ^? const pt: {}
pt.x = 3;
// ~ Property 'x' does not exist on type '{}'
//  ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì†ì„±ì„ ì¶”ê°€í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
pt.y = 4;
// ~ Property 'y' does not exist on type '{}'

// interface
interface Point {
  x: number;
  y: number;
}
const pt: Point = {}; // ì†ì„±ì´ ì—†ë‹¤!
// ~~ Type '{}' is missing the following properties from type 'Point': x, y
pt.x = 3;
pt.y = 4;

// í•´ê²°A: í•œ ë²ˆì— ê°ì²´ ìƒì„±í•˜ê¸°
const pt: Point = {
  x: 3,
  y: 4, // í•œ ë²ˆì— ì •ì˜í•˜ê¸°!
};

// í•´ê²°B: ë‹¨ì–¸
const pt = {} as Point;
//    ^? const pt: Point
pt.x = 3;
pt.y = 4; // OK
```

### ê°ì²´ ì „ê°œ ì—°ì‚°ì (spread) ì‚¬ìš©í•˜ê¸°

- í•„ë“œ ë‹¨ìœ„ì˜ ê°ì²´ ìƒì„± ê°€ëŠ¥
  - ê°ì²´ì— ì†ì„±ì„ ì¶”ê°€í•˜ê³ , íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ìƒˆë¡œìš´ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ë°©ë²•

```tsx
const pt0 = {};
const pt1 = { ...pt0, x: 3 };
const pt: Point = { ...pt1, y: 4 }; // OK
```

- ì¡°ê±´ë¶€ ì†ì„±ì„ ì¶”ê°€í•˜ê¸° ì˜ˆì‹œ
  - {} ë˜ëŠ” nullë¡œ ê°ì²´ ì „ê°œë¥¼ ì‚¬ìš©í•œë‹¤

```tsx
declare let hasMiddle: boolean;
const firstLast = { first: "Harry", last: "Truman" };
const president = { ...firstLast, ...(hasMiddle ? { middle: "S" } : {}) };
//    ^? const president: {
//         middle?: string; // ì„ íƒì  ì†ì„±ìœ¼ë¡œ ì¶”ë¡ ë¨!
//         first: string;
//         last: string;
//       }
// or: const president = {...firstLast, ...(hasMiddle && {middle: 'S'})};
```

- ì „ê°œ ì—°ì‚°ìë¡œ ì—¬ëŸ¬ ì†ì„±ì„ ì¶”ê°€í•˜ê¸°

```tsx
function addOptional<T extends object, U extends object>(
  a: T,
  b: U | null
): T & Partial<U> {
  return { ...a, ...b };
}
```

### Things to Remember

- Prefer to build objects all at once rather than piecemeal.
  - ì†ì„±ì„ ì œê°ê° ì¶”ê°€í•˜ì§€ ë§ê³ , í•œë²ˆì— ê°ì²´ë¡œ ë§Œë“¤ê¸°
- Use multiple objects and object spread syntax ({...a, ...b}) to add properties in a type-safe way.
  - ì—¬ëŸ¬ ì˜¤ë¸Œì íŠ¸ë¥¼ ìŠ¤í”„ë ˆë“œ ë¬¸ë²•ì„ ì‚¬ìš©í•´ì„œ ì•ˆì „í•œ íƒ€ì…ìœ¼ë¡œ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤
- Know how to conditionally add properties to an object.
  - ê°ì²´ì— ì¡°ê±´ë¶€ë¡œ ì†ì„± ì¶”ê°€í•˜ëŠ” ë²• ì•Œì•„ë‘ê¸° (ì˜µì…”ë„ ì†ì„±)
