> [!Note]  
> _8주차 발표자료입니다._

---

### 아이템 61: 의존성 관계에 따라 모듈 단위로 전환하기

프론트엔드 애플리케이션을 점진적으로 타입스크립트로 마이그레이션하는 과정에서, 모듈 간의 의존성 문제는 자주 직면하는 과제입니다. 이를 효과적으로 해결하기 위해서는 의존성 그래프를 그려보고, 최하단 모듈부터 단계적으로 전환하는 것이 중요합니다.

---

### 점진적 마이그레이션 with 모듈

모듈 단위로 진행하는 점진적 마이그레이션은 복잡한 프로젝트에서도 안정적으로 타입스크립트를 도입할 수 있는 전략입니다. 다른 모듈에 의존하지 않는 최하단 모듈부터 시작하면 의존성 문제를 최소화할 수 있습니다.

#### 서드파티 라이브러리와 외부 API 타입 정보

먼저, 프로젝트가 의존하는 서드파티 라이브러리의 타입 정보를 해결해야 합니다. 서드파티 라이브러리는 프로젝트에 의존하지 않기 때문에, 이들의 타입 정보를 먼저 정의하는 것이 중요합니다. 외부 API의 타입 정보도 마찬가지로 우선적으로 해결해야 합니다. 외부 API의 타입 정보는 문맥이 부족해 타입스크립트가 추론하기 어려우므로, API 사양을 기반으로 타입을 정의해야 합니다.

---

### 의존성 그래프 시각화

의존성 그래프를 통해 모듈 간의 의존성을 시각화할 수 있습니다. 대부분의 프로젝트에서 의존성 최하단에는 유틸리티 모듈이 위치합니다. 따라서, 유틸리티 모듈부터 타입스크립트로 전환하는 것이 일반적입니다. 마이그레이션 과정에서는 타입 정보만 추가하고, 리팩토링은 피해야 합니다. 리팩토링 사항은 목록화하여 후속 작업으로 남겨두는 것이 좋습니다.

![image](https://github.com/dusunax/javascript/assets/94776135/aa005096-f1ff-40ff-8db6-1170fe6ce14b)

---

### 클래스 멤버 명시적으로 선언하기

타입스크립트로 전환할 때, 클래스 멤버를 명시적으로 선언하는 것이 중요합니다. IDE의 Quick Fix 기능을 사용하면 쉽게 해결할 수 있습니다. 예를 들어, 클래스 멤버가 선언되지 않았을 때 다음과 같은 오류가 발생합니다:

```tsx
class Greeting {
  constructor(name) {
    this.greeting = "Hello";
    //   ~~~~~~~~ Property 'greeting' does not exist on type 'Greeting'
    this.name = name;
    //   ~~~~ Property 'name' does not exist on type 'Greeting'
  }
  greet() {
    return `${this.greeting} ${this.name}`;
    //             ~~~~~~~~         ~~~~ Property ... does not exist
  }
}
```

- Quick Fix
  - Declare property '~~'
  - Add all missing members

![image](https://github.com/dusunax/javascript/assets/94776135/55504e63-8c12-4838-8137-74648f5a2dd0)

잘못된 설계를 발견하더라도 리팩토링하지 말고 기록만 해둡니다. 마이그레이션에 집중하는 것이 중요합니다!

---

### 타입이 바뀌는 값 처리

타입이 바뀌는 값을 처리할 때는 한꺼번에 객체를 생성하는 것이 좋습니다. 예를 들어, 아래와 같이 객체를 생성하면 오류가 발생할 수 있습니다:

```tsx
// js => ts
const state = {};
state.name = "New York";
//    ~~~~ Property 'name' does not exist on type '{}'
state.capital = "Albany";
//    ~~~~~~~ Property 'capital' does not exist on type '{}'

// ts
const state = {
  name: "New York",
  capital: "Albany",
}; // OK
```

임시방편으로 단언문을 사용할 수 있지만, 마이그레이션이 완료된 후에 문제를 제대로 해결해야 합니다:

```tsx
interface State {
  name: string;
  capital: string;
}
const state = {} as State;
state.name = "New York"; // OK
state.capital = "Albany"; // OK
```

JSDoc과 `@ts-check`를 사용해 타입 정보를 추가한 상태라면, TS로 전환하는 순간 타입 정보가 '무효화'될 수 있다는 점에 주의해야 합니다. JSDoc 타입을 타입스크립트 타입 구문으로 변환하는 작업이 필요합니다.

- Quick Fix > Annotate with type from JSDoc
  - JSDoc을 사용해 타입 구문을 생성한 후, JSDoc을 삭제합니다!

![image](https://github.com/dusunax/javascript/assets/94776135/a8b461a0-8fed-464e-8f68-fd6c6a10e85a)

---

### 테스트 코드의 타입스크립트 전환

마이그레이션의 마지막 단계로, 테스트 코드를 타입스크립트로 전환합니다. 테스트 코드는 의존성 관계도의 최상단에 위치하므로, 마이그레이션의 마지막 단계로 처리하는 것이 좋습니다.

### 요약

1. **마이그레이션의 시작**: 서드파티 모듈과 외부 API 호출에서 타입 정보를 추가합니다.
2. **모듈 전환**: 의존성 관계도의 최하단부터 상단으로 마이그레이션합니다. 유틸리티 모듈부터 시작하는 것이 좋습니다.
3. **리팩토링 지양**: 이상한 설계를 발견해도 리팩토링을 피하고, 마이그레이션에 집중합니다. 리팩토링은 목록화하여 나중에 처리합니다.
4. **공통 오류 주의**: JSDoc 타입을 타입스크립트 타입으로 변환하고, 타입스크립트로 전환하면서 발생하는 일반적인 오류를 놓치지 않도록 합니다.

---

## 아이템 62: 마이그레이션의 완성을 위해 noImplicitAny 설정하기

타입스크립트 마이그레이션의 최종 단계는 `noImplicitAny` 설정을 활성화하는 것입니다. 이를 통해 타입 선언과 관련된 실제 오류를 드러나게 할 수 있습니다. 처음에는 로컬에서만 옵션을 설정하고, 점진적으로 수정한 부분만 커밋하여 마이그레이션을 진행합니다.

---

### noImplicitAny 설정의 중요성

타입스크립트에서 `noImplicitAny` 설정은 중요한 설정 중 하나로, 코드에서 명시적으로 타입을 지정하지 않은 경우에 발생하는 오류를 강제화합니다. 타입스크립트의 타입 시스템을 최대한 활용하여 코드 안정성을 높이는 데 중요한 역할을 합니다.

#### 타입 강화 단계

타입스크립트 마이그레이션 과정에서 다음과 같은 순서로 타입 체크 강도를 서서히 높일 수 있습니다.

1. **strictNullChecks**: null 및 undefined의 사용을 엄격하게 검사하여 이러한 값이 예상치 못한 곳에서 발생하는 오류를 방지합니다.
2. **noImplicitAny**: 명시적으로 타입을 선언하지 않은 경우에 오류를 발생시켜, 모든 변수와 함수의 타입이 명시적으로 선언되도록 강제합니다.
3. **strict**: 타입 검사를 최대한 엄격하게 설정하여 가능한 모든 타입 오류를 검출하고 방지합니다.

#### 점진적인 마이그레이션

프로젝트에서 `noImplicitAny` 설정을 활성화할 때는 점진적인 접근을 고려합니다.

- **로컬 설정**: 먼저 개발 환경에서만 `noImplicitAny`를 설정하여 해당 설정이 프로젝트 전체에 영향을 미치지 않도록 합니다.
- **오류 수정**: 컴파일러가 발생시키는 `any` 타입 관련 오류를 점진적으로 수정하고, 각 수정 사항을 커밋합니다.

---

## 결론

타입스크립트로의 마이그레이션은 단순한 작업이 아니며, 프로젝트의 규모와 복잡성에 따라 다양한 고려 사항이 필요합니다.

의존성 그래프 등을 활용해 정확한 계획과 절차를 통해 점진적으로 타입스크립트를 도입하고 안정적으로 완료해 나가는 것이 중요합니다.

마이그레이션 과정에서 발생한 오류와 잘못된 코드를 기록하는 것, 팀 전체가 타입스크립트에 익숙해질 수 있도록 하는 것도 중요한 과정입니다.
