# DIL: 이펙티브 타입스크립트

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> 작성일: 2024-06-05
> 작성자: paran22

---

## 아이템 42. 모르는 타입의 값에는 any 대신 unknown을 사용하기
- 어떤 타입이든 any 타입에 할당 가능하고, any 타입은 어떤 타입으로도 할당 가능하다.
- 한 집합은 다른 모든 집합의 부분 집합이면서 동시에 상위 집합이 될 수 없기 때문에 any는 타입 시스템과 상충되는 면이 있다.
- unknown 타입은 어떤 타입이든 할당 가능하지만, unknown은 오직 unknown과 any에만 할당 가능하다.
- never은 어떤 타입도 never에 할당할 수 없고, 어떠한 타입으로도 할등 가능하다.
- unknown 상태로 사용하려고 하면 오류가 발생하기 때문에, 타입 단언문, instanceof, 사용자 정의 타입 가드를 통해 적절한 타입으로 변환하도록 강제할 수 있다.
- any와 달리 unknown은 분리되는 즉시 오류를 발생하게 되므로 더 안전하다.
- {}은 null과 undefined를 제외한 모든 값을 포함하므로, null과 undefined가 불가능하다고 판단되는 경우만 unknown을 대신 사용하면 된다.

## 아이템 43. 몽키 패치보다는 안전한 타입을 사용하기
- 객체에 임의의 속성을 추가하는 것은 일반적으로 좋은 설계가 아니다.
- 타입 체커는 임의로 추가한 속성에 대해서는 알지 못한다.
- 데이터를 분리하는 것이 좋고, 분리할 수 없는 경우에는 두 가지 차선택이 있다.
- interface의 특수 기능 중 하나인 보강(augmentation)이 있다.
- 그렇지만 보강은 모듈의 관점에서 제대로 동작하려면 global 선언을 추가해 전역적으로 적용되기 때문에 코드의 다른 부분이나 라이브러리로부터 분리할 수 없다. 또, 애플리케이션이 실행되는 동안 속성을 할당하면 실행 시점에서 보강을 적용할 방법이 없다.
- 타입을 확장하는 새로운 타입을 도입해 더 구체적인 타입 단언문을 사용하면 모듈 영역 문제도 해결할 수 있다.

## 아이템 44. 타입 커버리지를 추적하여 타입 안전성 유지하기
- noImplicitAny를 설정해도 any는 명시적으로 any 타입으로 선언하거나, 서드파티 타입에 선언된 경우에는 any 타입이 여전히 존재할 수 있다.
- npm의 type-coverage 패키지를 활용하면 any를 추적할 수 있다.
- 타입 커버리지를 추적해 any가 더 이상 필요하지 않은지, 불필요한 선언인지 점검할 수 있다.