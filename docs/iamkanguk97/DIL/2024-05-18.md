# DIL: 이펙티브 타입스크립트

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> 작성일: 2024-05-18
> 작성자: iamkanguk97

---

## 아이템9: 타입 단언보다는 타입 선언을 사용하기

### 변수에 값을 할당하고 타입을 부여하는 방법은 2가지

```typescript
interface Person {
  name: string;
}

const alice: Person = { name: 'Alice' }; // 타입은 Person
const bob = { name: 'Alice' } as Person; // 타입은 Person
```

- alice: 변수에 `타입 선언`을 붙여서 그 값이 선언된 타입임을 명시한다.
- bob: "as Person"을 통해 `타입 단언`을 수행한다. 그러면 **타입스크립트가 추론한 타입이 있더라도 Person 타입으로 간주한다.**

### 타입 단언보다 타입 선언을 사용하는 것이 좋다.

```typescript
const alice: Person = {}; // 오류: Person 유형에 필요한 'name' 속성이 없다.
const bob = {} as Person; // 오류 없음
```

- **타입 선언**: 할당되는 값이 해당 인터페이스를 만족하는지 검사. (alice에 할당된 값이 Person 인터페이스를 만족하는지 타입스크립트에서 확인함)
- **타입 단언**: 강제로 타입을 지정했기 때문에 타입 체커에게 오류를 무시하라고 하는 것

마찬가지로 속성을 인터페이스에 추가할 때도 문제가 발생할 수 있다.

```typescript
const alice: Person = {
  name: 'Alice',
  occupation: 'TypeScript Developer',
  //~~~~~~~~~~~ 개체 리터럴은 알려진 속성만 지정할 수 있으며
  //            'Person' 형식에 'occupation'이 없습니다.
};

const bob = { name: 'Bob', occupation: 'JavaScript Developer' } as Person; // 정상
```

> 참고) const bob = <Person>{}
>
> - 위 문법은 {} as Person과 동일하다.
> - 하지만 위와 같은 코드는 타입스크립트 + 리액터에서 컴포넌트 태그로 인식되기 때문에 현재는 잘 쓰지 않는다.

### 화살표 함수의 타입 선언

화살표 함수의 타입 선언은 추론된 타입이 모호할 때가 있다.

```typescript
// Person[]을 언했지만 결과는 { name: string }[]
const people = ['alice', 'bob', 'jan'].map((name) => ({ name }));

const people = ['alice', 'bob', 'jan'].map((name) => ({ name } as Person)); // 타입 단언 사용 -> People[] 반환됨

const people = ['alice', 'bob', 'jan'].map((name) => ({} as Person)); // 이것도 문제가 없다고 추론됨
```

- 첫 번째 줄에서는 우리가 원하는 Person[] 이 추론되지 않았음.
- 그래서 타입 단언을 사용해서 Person[]을 추론받았지만 실제로는 해결된 것이 아니다.
- 마지막 줄처럼 코드를 작성해도 문제가 발생하지 않는다..

그래서 우리는 단언문을 쓰지 않고 다음과 같이 화살표 함수 안에서 타입과 함께 변수를 선언하는 것이 가장 직관적이다.

```typescript
const people = ['alice', 'bob', 'jan'].map((name) => {
  const person: Person = { name };
  return person;
}); // 타입은 Person[]

// 위의 코드를 조금 더 간결하게!
const people = ['alice', 'bob', 'jan'].map((name): Person => ({ name }));
```

### DOM 엘리먼트 => 타입 단언?

```typescript
document.querySelector('#myButton').addEventListener('click', (e) => {
  e.currentTarget; // 타입은 EventTarget
  const button = e.currentTarget as HTMLButtonElement;
  button; // 타입은 HTMLButtonElement
});
```

- 타입스크립트는 DOM에 접근할 수 없다.
- 그렇기 때문에 `#myButton`이 버튼 엘리먼트인지 알지 못한다.
- 그리고 이벤트의 `currentTarget`이 같은 버튼이어야 하는 것도 알지 못한다.
- 따라서 이런 경우에는 타입 단언을 사용하는 것이 타당하다.

### Non-Null Assertion (Null이 아니라고 단언)

```typescript
const elNull = document.getElementById('foo'); // HTMLElement | null
const el = document.getElementById('foo')!; // HTMLElement
```

- !는 일반적인 단언문처럼 생각해야 한다.
- **단언문은 컴파일 과정 중에 제거되기 때문에 타입 체커는 알지 못하지만 그 값이 null이 아니라고 개발자가 확신할 수 있을 때 사용해야 한다.**
- **만약 확신하지 못한다면 null인 경우를 체크하는 조건문을 추가해야 한다.**

### 타입 단언문으로 임이의 타입 간에 변환을 할 수 없다.

- A가 B의 부분집합인 경우에는 타입 단언물을 사용해서 변환할 수 있다.
  - HTMLElement는 HTMLElement | null의 서브타입이기 때문에 가능.
  - HTMLButtonElement는 EventTarget의 서브타입이기 때문에 가능.
  - Person은 {}의 서브타입이기 때문에 가능하다.
- **하지만 Person과 HTMLElement는 서브타입이 아니기 때문에 불가능.**

```typescript
interface Person {
  name: string;
}

const body = document.body;
const el = body as Person;
//         ~~~~~~~~~~~~~~ 'HTMLElement' 형식을 'Person' 형식으로 변환하는 것은
//                        형식이 다른 형식과 충분히 겹치지 않기 때문에
//                        실수일 수 있습니다. 이것이 의도적인 경우에는
//                        먼저 식을 'unknown'으로 변환하십시오.
```

- 위의 문제를 해결하기 위해서는 `unknown` 타입을 사용하면 된다.
- **모든 타입은 unknown의 서브타입**이기 때문에 unknown이 포함된 단언문은 항상 동작한다.
