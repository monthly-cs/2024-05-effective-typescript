# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-06-01
> ì‘ì„±ì: w00khyung

---

# ì•„ì´í…œ 28 ìœ íš¨í•œ ìƒíƒœë§Œ í‘œí˜„í•˜ëŠ” íƒ€ì…ì„ ì§€í–¥í•˜ê¸°

### íš¨ê³¼ì ìœ¼ë¡œ íƒ€ì…ì„ ì„¤ê³„í•˜ë ¤ë©´, ìœ íš¨í•œ ìƒíƒœë§Œ í‘œí˜„í•  ìˆ˜ ìˆëŠ” íƒ€ì…ì„ ë§Œë“¤ì–´ ë‚´ëŠ” ê²ƒì´ ì¤‘ìš”í•˜ë‹¤.

```tsx
// í˜ì´ì§€ì˜ ìƒíƒœë¥¼ ë‹¤ìŒì²˜ëŸ¼ ì„¤ê³„í–ˆë‹¤.
interface State {
  pageText: string
  isLoading: boolean
  error?: string
}

declare let currentPage: string

// ìƒíƒœ ê°ì²´ì˜ í•„ë“œë¥¼ ì „ë¶€ ê³ ë ¤í•´ì„œ ìƒíƒœ í‘œì‹œë¥¼ ë¶„ê¸°í•´ì•¼ í•œë‹¤.
// ğŸ¤” isLoadingì´ trueì´ê³  ë™ì‹œì— error ê°’ì´ ì¡´ì¬í•˜ë©´ ìƒíƒœë¥¼ ëª…í™•íˆ êµ¬ë¶„í•  ìˆ˜ ì—†ë‹¤.
function renderPage(state: State) {
  if (state.error) {
    return `Error! Unable to load ${currentPage}: ${state.error}`
  } else if (state.isLoading) {
    return `Loading ${currentPage}...`
  }
  return `<h1>${currentPage}</h1>\n${state.pageText}`
}

function getUrlForPage(p: string) {
  return ''
}

// í˜ì´ì§€ë¥¼ ì „í™˜í•˜ëŠ” í•¨ìˆ˜
async function changePage(state: State, newPage: string) {
  state.isLoading = true

  try {
    const response = await fetch(getUrlForPage(newPage))
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`)
      // ì˜¤ë¥˜ê°€ ë°œìƒí–ˆì„ ë•Œ state.isLoadingì„ falseë¡œ ì„¤ì •í•´ì•¼ í•œë‹¤.
    }

    // í˜ì´ì§€ ë¡œë”© ì¤‘ì— ì‚¬ìš©ìê°€ í˜ì´ì§€ë¥¼ ë°”ê¿” ë²„ë¦¬ë©´ ì–´ë–¤ ì¼ì´ ë²Œì–´ì§ˆì§€ ì˜ˆìƒí•˜ê¸° ì–´ë µë‹¤.
    // ìƒˆ í˜ì´ì§€ì— ì˜¤ë¥˜ê°€ ëœ¨ê±°ë‚˜, ì‘ë‹µì´ ì˜¤ëŠ” ìˆœì„œì— ë”°ë¼ ë‘ ë²ˆì§¸ í˜ì´ì§€ê¸° ì•„ë‹Œ ì²« ë²ˆì§¸ í˜ì´ì§€ë¡œ ì „í™˜ë  ìˆ˜ë„ ìˆë‹¤.
    const text = await response.text()
    state.isLoading = false
    state.pageText = text
  } catch (e) {
	  // state.errorë¥¼ ì´ˆê¸°í™”í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì—, í˜ì´ì§€ ì „í™˜ ì¤‘ì— ë¡œë”© ë©”ì‹œì§€ ëŒ€ì‹  ê³¼ê±°ì˜ ì˜¤ë¥˜ ë©”ì„¸ì§€ê°€ ë³´ì¸ë‹¤.
    **state.error = '' + e**
  }
}
```

```tsx
// ë¬´íš¨í•œ ìƒíƒœë¥¼ í—ˆìš©í•˜ì§€ ì•Šë„ë¡ ê°œì„ í•˜ì˜€ë‹¤.
interface RequestPending {
  state: 'pending';
}

interface RequestError {
  state: 'error';
  error: string;
}

interface RequestSuccess {
  state: 'ok';
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess;

interface State {
  currentPage: string;
  requests: { [page: string]: RequestState };
}

function getUrlForPage(p: string) {
  return '';
}

function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];
  switch (requestState.state) {
    case 'pending':
      return `Loading ${currentPage}...`;
    case 'error':
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case 'ok':
      return `<h1>${currentPage}</h1>\n${requestState.pageText}`;
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: 'pending' };
  state.currentPage = newPage;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error(`Unable to load ${newPage}: ${response.statusText}`);
    }
    const pageText = await response.text();
    state.requests[newPage] = { state: 'ok', pageText };
  } catch (e) {
    state.requests[newPage] = { state: 'error', error: '' + e };
  }
}
```

```tsx
interface CockpitControls {
  /** Angle of the left side stick in degrees, 0 = neutral, + = forward */
  leftSideStick: number;
  /** Angle of the right side stick in degrees, 0 = neutral, + = forward */
  rightSideStick: number;
}

function getStickSetting(controls: CockpitControls) {
  return controls.leftSideStick;
}

// ë‘˜ ì¤‘ í•˜ë‚˜ì˜ ìŠ¤í‹± ê°’ì¤‘ì—ì„œ ì¤‘ë¦½ì´ ì•„ë‹Œ ê°’ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  }
  return leftSideStick;
}

function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  } else if (rightSideStick === 0) {
    return leftSideStick;
  }
  // ???
  // ë‘ ìŠ¤í‹± ëª¨ë‘ ì¤‘ë¦½ì´ ì•„ë‹Œ ê²½ìš°ë¥¼ ê³ ë ¤í•´ë´ì•¼ í•œë‹¤.
}

function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if (leftSideStick === 0) {
    return rightSideStick;
  } else if (rightSideStick === 0) {
    return leftSideStick;
  }

  // ë‘ ìŠ¤í‹±ì´ ë¹„ìŠ·í•œ ê°’ì´ë¼ë©´ ìŠ¤í‹±ì˜ ê°ë„ë¥¼ í‰ê· í•´ì„œ ê³„ì‚°í•  ìˆ˜ ìˆë‹¤.
  if (Math.abs(leftSideStick - rightSideStick) < 5) {
    return (leftSideStick + rightSideStick) / 2;
  }

  // ê·¸ëŸ¬ë‚˜ ë‘ ìŠ¤í‹±ì˜ ê°ë„ê°€ ë§¤ìš° ë‹¤ë¥¸ ê²½ìš°ëŠ” í•´ê²°í•˜ê¸° ì–´ë µë‹¤.
  // ???
}

// ???
function getStickSetting(controls: CockpitControls) {
  return (controls.leftSideStick + controls.rightSideStick) / 2;
}
```

```tsx
interface CockpitControls {
  /** Angle of the stick in degrees, 0 = neutral, + = forward */
  stickAngle: number;
}
```

### ìš”ì•½

- ìœ íš¨í•œ ìƒíƒœì™€ ë¬´íš¨í•œ ìƒíƒœë¥¼ ë‘˜ ë‹¤ í‘œí˜„í•˜ëŠ” íƒ€ì…ì€ í˜¼ë€ì„ ì´ˆë˜í•˜ê¸° ì‰½ê³  ì˜¤ë¥˜ë¥¼ ìœ ë°œí•˜ê²Œ ëœë‹¤.
- ìœ íš¨í•œ ìƒíƒœë§Œ í‘œí˜„í•œ íƒ€ì…ì„ ì§€í–¥í•´ì•¼ í•œë‹¤. ì½”ë“œê°€ ê¸¸ì–´ì§€ê±°ë‚˜ í‘œí˜„í•˜ê¸° ì–´ë µì§€ë§Œ ê²°êµ­ì€ ì‹œê°„ì„ ì ˆì•½í•˜ê³  ê³ í†µì„ ì¤„ì¼ ìˆ˜ ìˆë‹¤.

# ì•„ì´í…œ 29 ì‚¬ìš©í•  ë•ŒëŠ” ë„ˆê·¸ëŸ½ê²Œ, ìƒì„±í•  ë•ŒëŠ” ì—„ê²©í•˜ê²Œ

- í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ëŠ” íƒ€ì…ì˜ ë²”ìœ„ê°€ ë„“ì–´ë„ ë˜ì§€ë§Œ, ê²°ê³¼ë¥¼ ë°˜í™˜í•  ë•ŒëŠ” ì¼ë°˜ì ìœ¼ë¡œ íƒ€ì…ì˜ ë²”ìœ„ê°€ ë” êµ¬ì²´ì ì´ì–´ì•¼ í•œë‹¤.

```tsx
interface CameraOptions {
  center?: LngLat;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
type LngLat = { lng: number; lat: number } | { lon: number; lat: number } | [number, number];
type LngLatBounds = { northeast: LngLat; southwest: LngLat } | [LngLat, LngLat] | [number, number, number, number];

declare function setCamera(camera: CameraOptions): void;
declare function viewportForBounds(bounds: LngLatBounds): CameraOptions;
```

```tsx
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    zoom,
  } = camera;
  // ~~~      Property 'lat' does not exist on type ...
  //      ~~~ Property 'lng' does not exist on type ...
  zoom; // Type is number | undefined
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

```tsx
interface LngLat {
  lng: number;
  lat: number;
}
type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

interface Camera {
  center: LngLat;
  zoom: number;
  bearing: number;
  pitch: number;
}
interface CameraOptions extends Omit<Partial<Camera>, 'center'> {
  center?: LngLatLike;
}
type LngLatBounds =
  | { northeast: LngLatLike; southwest: LngLatLike }
  | [LngLatLike, LngLatLike]
  | [number, number, number, number];
```

```tsx
interface LngLat {
  lng: number;
  lat: number;
}

type LngLatLike = LngLat | { lon: number; lat: number } | [number, number];

interface CameraOptions {
  center?: LngLatLike;
  zoom?: number;
  bearing?: number;
  pitch?: number;
}
```

```tsx
function focusOnFeature(f: Feature) {
  const bounds = calculateBoundingBox(f);
  const camera = viewportForBounds(bounds);
  setCamera(camera);
  const {
    center: { lat, lng },
    zoom,
  } = camera; // OK
  zoom; // Type is number
  window.location.search = `?v=@${lat},${lng}z${zoom}`;
}
```

### ìš”ì•½

- ë³´í†µ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì€ ë°˜í™˜ íƒ€ì…ì— ë¹„í•´ ë²”ìœ„ê°€ ë„“ì€ ê²½í–¥ì´ ìˆìŠµë‹ˆë‹¤. ì„ íƒì  ì†ì„±ê³¼ ìœ ë‹ˆì˜¨ íƒ€ì…ì€ ë°˜í™˜ íƒ€ì…ë³´ë‹¤ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì— ë” ì¼ë°˜ì ì…ë‹ˆë‹¤.
- ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ íƒ€ì…ì˜ ì¬ì‚¬ìš©ì„ ìœ„í•´ì„œ ê¸°ë³¸ í˜•íƒœ(ë°˜í™˜ íƒ€ì…)ì™€ ëŠìŠ¨í•œ í˜•íƒœ(ë§¤ê°œë³€ìˆ˜ íƒ€ì…)ë¥¼ ë„ì…í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

# ì•„ì´í…œ 30 ë¬¸ì„œì— íƒ€ì… ì •ë³´ë¥¼ ì“°ì§€ ì•Šê¸°

```tsx
/**
 * Returns a string with the foreground color.
 * Takes zero or one arguments. With no arguments, returns the
 * standard foreground color. With one argument, returns the foreground color
 * for a particular page.
 */

// ì½”ë“œì™€ ì£¼ì„ì˜ ì •ë³´ê°€ ë§ì§€ ì•Šë‹¤.
// í•¨ìˆ˜ê°€ string í˜•íƒœì˜ ìƒ‰ê¹”ì„ ë°˜í™˜í•œë‹¤ê³  ì í˜€ìˆì§€ë§Œ ì‹¤ì œë¡œëŠ” {r, g, b} ê°ì²´ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
// ì£¼ì„ì—ëŠ” í•¨ìˆ˜ê°€ 0ê°œ ë˜ëŠ” 1ê°œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ëŠ”ë‹¤ê³  ì„¤ëª…í•˜ê³  ìˆì§€ë§Œ, íƒ€ì… ì‹œê·¸ë‹ˆì²˜ë§Œ ë³´ì•„ë„ ëª…í™•í•˜ê²Œ ì•Œ ìˆ˜ ìˆëŠ” ì •ë³´ë‹¤.
// ë¶ˆí•„ìš”í•˜ê²Œ ì¥í™©í•©ë‹ˆë‹¤. í•¨ìˆ˜ ì„ ì–¸ê³¼ êµ¬í˜„ì²´ë³´ë‹¤ ì£¼ì„ì´ ë” ê¹ë‹ˆë‹¤.
function getForegroundColor(page?: string) {
  return page === 'login' ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 };
}
```

```tsx
type Color = { r: number; g: number; b: number };

/** Get the foreground color for the application or a specific page. */
function getForegroundColor(page?: string): Color {
  return page === 'login' ? { r: 127, g: 127, b: 127 } : { r: 0, g: 0, b: 0 };
}
```

```tsx
/** Does not modify nums */
// ë§¤ê°œë³€ìˆ˜ë¥¼ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ì£¼ì„ë„ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ê²ƒì´ ì¢‹ë‹¤.
function sort(nums: number[]) {
  /* ... */
}

function sort(nums: readonly number[]) {
  /* ... */
}
```

### ìš”ì•½

- ì£¼ì„ê³¼ ë³€ìˆ˜ëª…ì— íƒ€ì… ì •ë³´ë¥¼ ì ëŠ” ê²ƒì€ í”¼í•´ì•¼ í•©ë‹ˆë‹¤. íƒ€ì… ì„ ì–¸ì´ ì¤‘ë³µë˜ëŠ” ê²ƒìœ¼ë¡œ ëë‚˜ë©´ ë‹¤í–‰ì´ì§€ë§Œ ìµœì•…ì˜ ê²½ìš°ëŠ” íƒ€ì… ì •ë³´ì— ëª¨ìˆœì´ ë°œìƒí•˜ê²Œ ë©ë‹ˆë‹¤.
- íƒ€ì…ì´ ëª…í™•í•˜ì§€ ì•Šì€ ê²½ìš°ëŠ” ë³€ìˆ˜ëª…ì— ë‹¨ìœ„ ì •ë³´ë¥¼ í¬í•¨í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. (ì˜ˆë¥¼ ë“¤ì–´ `timeMs` ë˜ëŠ” `temperatureC`).

# ì•„ì´í…œ 31 íƒ€ì… ì£¼ë³€ì— null ê°’ ë°°ì¹˜í•˜ê¸°

- ê°’ì´ ì „ë¶€ nullì´ê±°ë‚˜ ì „ë¶€ nullì´ ì•„ë‹Œ ê²½ìš°ë¡œ ë¶„ëª…íˆ êµ¬ë¶„ëœë‹¤ë©´, ê°’ì´ ì„ì—¬ ìˆì„ ë•Œë³´ë‹¤ ë‹¤ë£¨ê¸° ì‰½ë‹¤.
  - íƒ€ì…ì— nullì„ ì¶”ê°€í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì´ëŸ¬í•œ ê²½ìš°ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆë‹¤.

```tsx
// ìµœì†Ÿê°’ì´ë‚˜ ìµœëŒ“ê°’ì´ 0ì¸ ê²½ìš°, ê°’ì´ ë§ì”Œì›Œì ¸ ë²„ë¦°ë‹¤.
// nums ë°°ì—´ì´ ë¹„ì–´ ìˆë‹¤ë©´ í•¨ìˆ˜ëŠ” [undefined, undefined]ë¥¼ ë°˜í™˜í•œë‹¤.
function extent(nums: number[]) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      max = Math.max(max, num);
    }
  }
  return [min, max];
}

// strictNullChecks ì„¤ì •ì„ ì¼œë©´ ì•ì˜ ë‘ ê°€ì§€ ë¬¸ì œì ì´ ë“œëŸ¬ë‚œë‹¤.
function extent(nums: number[]) {
  let min, max;
  for (const num of nums) {
    if (!min) {
      min = num;
      max = num;
    } else {
      min = Math.min(min, num);
      // undefinedë¥¼ maxì—ì„œëŠ” ì œì™¸í•˜ì§€ ì•Šì•˜ê¸° ë•Œë¬¸ì— ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
      max = Math.max(max, num);
      // ~~~ Argument of type 'number | undefined' is not
      //     assignable to parameter of type 'number'
    }
  }
  return [min, max];
}

const [min, max] = extent([0, 1, 2]);
const span = max - min;
// ~~~   ~~~ Object is possibly 'undefined'
```

```tsx
function extent(nums: number[]) {
  // minê³¼ maxë¥¼ í•œ ê°ì²´ ì•ˆì— ë„£ê³  nullì´ê±°ë‚˜ nullì´ ì•„ë‹ˆê²Œ í•˜ë©´ ëœë‹¤.
  let result: [number, number] | null = null;
  for (const num of nums) {
    if (!result) {
      result = [num, num];
    } else {
      result = [Math.min(num, result[0]), Math.max(num, result[1])];
    }
  }
  return result;
}

const range = extent([0, 1, 2]);

if (range) {
  const [min, max] = range;
  const span = max - min; // OK
}
```

```tsx
// nullê³¼ nullì´ ì•„ë‹Œ ê°’ì„ ì„ì–´ì„œ ì‚¬ìš©í•˜ë©´ í´ë˜ìŠ¤ì—ì„œë„ ë¬¸ì œê°€ ìƒê¸´ë‹¤.
interface UserInfo {
  name: string;
}

interface Post {
  post: string;
}

declare function fetchUser(userId: string): Promise<UserInfo>;
declare function fetchPostsForUser(userId: string): Promise<Post[]>;

class UserPosts {
  user: UserInfo | null;
  posts: Post[] | null;

  constructor() {
    this.user = null;
    this.posts = null;
  }

  // ë‘˜ ë‹¤ nullì´ê±°ë‚˜, ë‘˜ ì¤‘í•˜ë‚˜ë§Œ nullì´ê±°ë‚˜, ë‘˜ ë‹¤ nullì´ ì•„ë‹Œ ê²½ìš°ê°€ ìƒê¸´ë‹¤.
  async init(userId: string) {
    return Promise.all([
      async () => (this.user = await fetchUser(userId)),
      async () => (this.posts = await fetchPostsForUser(userId)),
    ]);
  }

  getUserName() {
    // ...?
  }
}
```

```tsx
// í•„ìš”í•œ ë°ì´í„°ê°€ ëª¨ë‘ ì¤€ë¹„ëœ í›„ì— í´ë˜ìŠ¤ê°€ ë§Œë“¤ì–´ì§€ë„ë¡ ê°œì„ í•˜ì˜€ë‹¤.
class UserPosts {
  user: UserInfo;
  posts: Post[];

  constructor(user: UserInfo, posts: Post[]) {
    this.user = user;
    this.posts = posts;
  }

  static async init(userId: string): Promise<UserPosts> {
    const [user, posts] = await Promise.all([fetchUser(userId), fetchPostsForUser(userId)]);
    return new UserPosts(user, posts);
  }

  getUserName() {
    return this.user.name;
  }
}
```

### ìš”ì•½

- í•œ ê°’ì˜ null ì—¬ë¶€ê°€ ë‹¤ë¥¸ ê°’ì˜ null ì—¬ë¶€ì— ì•”ì‹œì ìœ¼ë¡œ ê´€ë ¨ë˜ë„ë¡ ì„¤ê³„í•˜ë©´ ì•ˆë©ë‹ˆë‹¤.
- API ì‘ì„± ì‹œì—ëŠ” ë°˜í™˜ íƒ€ì…ì„ í° ê°ì²´ë¡œ ë§Œë“¤ê³  ë°˜í™˜ íƒ€ì… ì „ì²´ê°€ nullì´ê±°ë‚˜ nullì´ ì•„ë‹ˆê²Œ ë§Œë“¤ì–´ì•¼ í•©ë‹ˆë‹¤. ì‚¬ëŒê³¼ íƒ€ì… ì²´ì»¤ ëª¨ë‘ì—ê²Œ ëª…ë£Œí•œ ì½”ë“œê°€ ë  ê²ƒì…ë‹ˆë‹¤.
- í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ ë•ŒëŠ” í•„ìš”í•œ ëª¨ë“  ê°’ì´ ì¤€ë¹„ë˜ì—ˆì„ ë•Œ ìƒì„±í•˜ì—¬ nullì´ ì¡´ì¬í•˜ì§€ ì•Šë„ë¡ í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
- `strictNullChecks` ë¥¼ ì„¤ì •í•˜ë©´ ì½”ë“œì— ë§ì€ ì˜¤ë¥˜ê°€ í‘œì‹œë˜ê² ì§€ë§Œ, null ê°’ê³¼ ê´€ë ¨ëœ ë¬¸ì œì ì„ ì°¾ì•„ë‚¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë°˜ë“œì‹œ í•„ìš”í•©ë‹ˆë‹¤.

# ì•„ì´í…œ 32 ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ë³´ë‹¤ëŠ” ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•˜ê¸°

```tsx
type FillPaint = unknown;
type LinePaint = unknown;
type PointPaint = unknown;
type FillLayout = unknown;
type LineLayout = unknown;
type PointLayout = unknown;

interface Layer {
  // layout ì†ì„±ì€ ëª¨ì–‘ì´ ê·¸ë ¤ì§€ëŠ” ë°©ë²•ê³¼ ìœ„ì¹˜(ë‘¥ê·¼ ëª¨ì„œë¦¬, ì§ì„ )ë¥¼ ì œì–´í•˜ëŠ” ë°˜ë©´,
  layout: FillLayout | LineLayout | PointLayout;
  // paint ì†ì„±ì€ ìŠ¤íƒ€ì¼(íŒŒë€ì„ , êµµì€ì„ , ì–‡ì€ì„ , ì ì„ )ì„ ì œì–´í•©ë‹ˆë‹¤.
  paint: FillPaint | LinePaint | PointPaint;
}

// layoutì´ LineLayout íƒ€ì…ì´ë©´ì„œ paint ì†ì„±ì´ FillPaint íƒ€ì…ì¸ ê²ƒì€ ë§ì´ ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
```

```tsx
interface FillLayer {
  type: 'fill';
  layout: FillLayout;
  paint: FillPaint;
}

interface LineLayer {
  type: 'line';
  layout: LineLayout;
  paint: LinePaint;
}

interface PointLayer {
  type: 'paint';
  layout: PointLayout;
  paint: PointPaint;
}

// type ì†ì„±ì€ 'íƒœê·¸'ì´ë©° ëŸ°íƒ€ì„ì— ì–´ë–¤ íƒ€ì…ì˜ Layerê°€ ì‚¬ìš©ë˜ëŠ”ì§€ íŒë‹¨í•˜ëŠ” ë° ì“°ì¸ë‹¤.
type Layer = FillLayer | LineLayer | PointLayer;

function drawLayer(layer: Layer) {
  if (layer.type === 'fill') {
    const { paint } = layer; // Type is FillPaint
    const { layout } = layer; // Type is FillLayout
  } else if (layer.type === 'line') {
    const { paint } = layer; // Type is LinePaint
    const { layout } = layer; // Type is LineLayout
  } else {
    const { paint } = layer; // Type is PointPaint
    const { layout } = layer; // Type is PointLayout
  }
}
```

```tsx
interface Person {
  name: string;
  // These will either both be present or not be present
  placeOfBirth?: string;
  dateOfBirth?: Date;
}

// ë‘ ê°œì˜ ì†ì„±ì„ í•˜ë‚˜ì˜ ê°ì²´ë¡œ ëª¨ìœ¼ëŠ” ê²ƒì´ ë” ë‚˜ì€ ì„¤ê³„ì…ë‹ˆë‹¤.
interface Person {
  name: string;
  birth?: {
    place: string;
    date: Date;
  };
}

// ì´ì œ placeë§Œ ìˆê³  dateê°€ ì—†ëŠ” ê²½ìš°ì—ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.
const alanT: Person = {
  name: 'Alan Turing',
  birth: {
    // ~~~~ Property 'date' is missing in type
    //      '{ place: string; }' but required in type
    //      '{ place: string; date: Date; }'
    place: 'London',
  },
};
```

```tsx
// person ê°ì²´ë¥¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ëŠ” í•¨ìˆ˜ëŠ” birth í•˜ë‚˜ë§Œ ì²´í¬í•˜ë©´ ë©ë‹ˆë‹¤.
function eulogize(p: Person) {
  console.log(p.name);
  const { birth } = p;
  if (birth) {
    console.log(`was born on ${birth.date} in ${birth.place}.`);
  }
}
```

```tsx
// íƒ€ì…ì˜ êµ¬ì¡°ë¥¼ ì† ëŒˆ ìˆ˜ ì—†ëŠ” ìƒí™©ì´ë©´, ì•ì„œ ë‹¤ë£¬ ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•´ì„œ
// ì†ì„± ì‚¬ì´ì˜ ê´€ê³„ë¥¼ ëª¨ë¸ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
interface Name {
  name: string;
}

interface PersonWithBirth extends Name {
  placeOfBirth: string;
  dateOfBirth: Date;
}

type Person = Name | PersonWithBirth;

// ì´ì œ ì¤‘ì²©ëœ ê°ì²´ì—ì„œë„ ë™ì¼í•œ íš¨ê³¼ë¥¼ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
function eulogize(p: Person) {
  if ('placeOfBirth' in p) {
    p; // Type is PersonWithBirth
    const { dateOfBirth } = p; // OK, type is Date
  }
}
```

### ìš”ì•½

- ìœ ë‹ˆì˜¨ íƒ€ì…ì˜ ì†ì„±ì„ ì—¬ëŸ¬ ê°œ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ì—ì„œëŠ” ì†ì„± ê°„ì˜ ê´€ê³„ê°€ ë¶„ëª…í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ì‹¤ìˆ˜ê°€ ìì£¼ ë°œìƒí•˜ë¯€ë¡œ ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤.
- ìœ ë‹ˆì˜¨ì˜ ì¸í„°í˜ì´ìŠ¤ë³´ë‹¤ ì¸í„°í˜ì´ìŠ¤ì˜ ìœ ë‹ˆì˜¨ì´ ë” ì •í™•í•˜ê³  íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì´í•´í•˜ê¸°ë„ ì¢‹ìŠµë‹ˆë‹¤.
- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì œì–´ íë¦„ì„ ë¶„ì„í•  ìˆ˜ ìˆë„ë¡ íƒ€ì…ì— íƒœê·¸ë¥¼ ë„£ëŠ” ê²ƒì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. íƒœê·¸ëœ ìœ ë‹ˆì˜¨ì€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì™€ ë§¤ìš° ì˜ ë§ê¸° ë•Œë¬¸ì— ìì£¼ ë³¼ ìˆ˜ ìˆëŠ” íŒ¨í„´ì…ë‹ˆë‹¤.

# ì•„ì´í…œ 33 string íƒ€ì…ë³´ë‹¤ ë” êµ¬ì²´ì ì¸ íƒ€ì… ì‚¬ìš©í•˜ê¸°

### string íƒ€ì…ì˜ ë²”ìœ„ëŠ” ë§¤ìš° ë„“ë‹¤

- string íƒ€ì…ì˜ ë³€ìˆ˜ë¥¼ ì„ ì–¸í•˜ë ¤ í•œë‹¤ë©´, í˜¹ì‹œ ê·¸ë³´ë‹¤ ë” ì¢ì€ íƒ€ì…ì´ ì ì ˆí•˜ì§€ëŠ” ì•Šì„ ì§€ ê²€í† í•´ ë³´ì•„ì•¼ í•©ë‹ˆë‹¤.

```tsx
// ìŒì•… ì»¬ë ‰ì…˜ì„ ë§Œë“¤ê¸° ìœ„í•´ ì•¨ë²”ì˜ íƒ€ì…ì„ ì •ì˜í•œë‹¤ê³  ê°€ì •í•´ë³´ì.
interface Album {
  artist: string;
  title: string;
  releaseDate: string; // YYYY-MM-DD
  recordingType: string; // E.g., "live" or "studio"
  // ğŸ¤” ì£¼ì„ì— íƒ€ì… ì •ë³´ë¥¼ ì ì–´ ë‘” ê±¸ ë³´ë©´ í˜„ì¬ ì¸í„°í˜ì´ìŠ¤ê°€ ì˜ëª»ë˜ì—ˆë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.
}

// ë‹¤ìŒ ì˜ˆì‹œì²˜ëŸ¼ Album íƒ€ì…ì— ì—‰ëš±í•œ ê°’ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
const kindOfBlue: Album = {
  artist: 'Miles Davis',
  title: 'Kind of Blue',
  releaseDate: 'August 17th, 1959', // ë‚ ì§œ í˜•ì‹ì´ ë‹¤ë¦…ë‹ˆë‹¤.
  recordingType: 'Studio', // ì˜¤íƒ€(ëŒ€ë¬¸ì S)
}; // ì •ìƒ

function recordRelease(title: string, date: string) {
  /* ... */
}

// string íƒ€ì…ì˜ ë²”ìœ„ê°€ ë§¤ìš° ë„“ê¸° ë•Œë¬¸ì— ì œëŒ€ë¡œ ëœ Album ê°ì²´ë¥¼ ì‚¬ìš©í•˜ë”ë¼ë„
// ë§¤ê°œë³€ìˆ˜ ìˆœì„œê°€ ì˜ëª»ëœ ê²ƒì´ ì˜¤ë¥˜ë¡œ ë“œëŸ¬ë‚˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
recordRelease(kindOfBlue.releaseDate, kindOfBlue.title); // OK, should be error
```

- ì•ì˜ ì˜ˆì œì²˜ëŸ¼ `string` íƒ€ì…ì´ ë‚¨ìš©ëœ ì½”ë“œë¥¼ â€œë¬¸ìì—´ì„ ë‚¨ë°œí•˜ì—¬ ì„ ì–¸ë˜ì—ˆë‹¤(stringly typed)â€ê³  í‘œí˜„í•˜ê¸°ë„ í•©ë‹ˆë‹¤.
- ì•ì˜ ì˜¤ë¥˜ë¥¼ ë°©ìí•˜ê¸° ìœ„í•´ releaseDateëŠ” Date ê°ì²´ë¥¼ ì‚¬ìš©í•´ì„œ ë‚ ì§œ í˜•ì‹ìœ¼ë¡œë§Œ ì œí•œí•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. recordingType í•„ë“œëŠ” â€œliveâ€ì™€ â€œstudioâ€, ë‹¨ ë‘ê°œì˜ ê°’ìœ¼ë¡œ ìœ ë‹ˆì˜¨ íƒ€ì…ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```tsx
type RecordingType = 'studio' | 'live';

interface Album {
  artist: string;
  title: string;
  releaseDate: Date;
  recordingType: RecordingType;
}

const kindOfBlue: Album = {
  artist: 'Miles Davis',
  title: 'Kind of Blue',
  releaseDate: new Date('1959-08-17'),
  // âœ… íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì˜¤ë¥˜ë¥¼ ë” ì„¸ë°€í•˜ê²Œ ì²´í¬í•©ë‹ˆë‹¤.
  recordingType: 'Studio',
  // ~~~~~~~~~~~~ Type '"Studio"' is not assignable to type 'RecordingType'
};
```

- ì´ëŸ¬í•œ ë°©ì‹ì€ ì„¸ ê°€ì§€ ì¥ì ì´ ë” ìˆìŠµë‹ˆë‹¤.

  1. íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜í•¨ìœ¼ë¡œì¨ ë‹¤ë¥¸ ê³³ìœ¼ë¡œ ê°’ì´ ì „ë‹¬ë˜ì–´ë„ íƒ€ì… ì •ë³´ê°€ ìœ ì§€ë©ë‹ˆë‹¤.
     1. ì˜ˆë¥¼ ë“¤ì–´, íŠ¹ì • ë ˆì½”ë”© íƒ€ì…ì˜ ì•¨ë²”ì„ ì°¾ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•œë‹¤ë©´ ë‹¤ìŒì²˜ëŸ¼ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ```tsx
  function getAlbumsOfType(recordingType: string): Album[] {
    // ...
  }

  // í•˜ì§€ë§Œ, í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ì‚¬ëŒì€ recordingTypeì´ "studio" ë˜ëŠ” "live"ì—¬ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ì—†ë‹¤.
  ```

  1. íƒ€ì…ì„ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜í•˜ê³  í•´ë‹¹ íƒ€ì…ì˜ ì˜ë¯¸ë¥¼ ì„¤ëª…í•˜ëŠ” ì£¼ì„ì„ ë¶™ì—¬ ë„£ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     1. getAlbumsOfTypeì´ ë°›ëŠ” ë§¤ê°œë³€ìˆ˜ë¥¼ string ëŒ€ì‹  RecordingTypeìœ¼ë¡œ ë°”ê¾¸ë©´, í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê³³ì—ì„œ RecordingTypeì˜ ì„¤ëª…ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

  ```tsx
  /** What type of environment was this recording made in?  */
  type RecordingType = 'live' | 'studio';
  ```

  1. keyof ì—°ì‚°ìë¡œ ë”ìš± ì„¸ë°€í•˜ê²Œ ê°ì²´ì˜ ì†ì„± ì²´í¬ê°€ ê°€ëŠ¥í•´ì§‘ë‹ˆë‹¤.

     ```tsx
     // ì–´ë–¤ ë°°ì—´ì—ì„œ í•œ í•„ë“œì˜ ê°’ë§Œ ì¶”ì¶œí•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•œë‹¤ê³  ìƒê°í•´ ë³´ê² ìŠµë‹ˆë‹¤.
     // ì‹¤ì œë¡œ ì–¸ë”ìŠ¤ì½”ì–´(Underscore) ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ëŠ” pluckì´ë¼ëŠ” í•¨ìˆ˜ê°€ ìˆìŠµë‹ˆë‹¤.
     function pluck(record, key) {
       return record.map((r) => r[key]);
     }

     // pluck í•¨ìˆ˜ì˜ ì‹œê·¸ë‹ˆì²˜ë¥¼ ë‹¤ìŒì²˜ëŸ¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
     // íƒ€ì… ì²´í¬ê°€ ë˜ê¸´ í•˜ì§€ë§Œ any íƒ€ì…ì´ ìˆì–´ì„œ ì •ë°€í•˜ì§€ ëª»í•©ë‹ˆë‹¤.
     // íŠ¹íˆ ë°˜í™˜ê°’ì— anyë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ë§¤ìš° ì¢‹ì§€ ì•Šì€ ì„¤ê³„ì…ë‹ˆë‹¤.
     function pluck(record: any[], key: string): any[] {
       return record.map((r) => r[key]);
     }

     // íƒ€ì… ì‹œê·¸ë‹ˆì²˜ë¥¼ ê°œì„ í•˜ëŠ” ì²« ë‹¨ê³„ë¡œ ì œë„ˆë¦­ íƒ€ì…ì„ ë„ì…í•´ ë³´ê² ìŠµë‹ˆë‹¤.
     function pluck<T>(record: T[], key: string): any[] {
       // keyì˜ íƒ€ì…ì´ stringì´ê¸° ë•Œë¬¸ì— ë²”ìœ„ê°€ ë„ˆë¬´ ë„“ë‹¤ëŠ” ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
       return record.map((r) => r[key]);
       // ~~~~~~ Element implicitly has an 'any' type
       //        because type '{}' has no index signature
     }

     type K = keyof Album;
     // Type is "artist" | "title" | "releaseDate" | "recordingType"

     // keyëŠ” ë‹¨ ë„¤ ê°œì˜ ê°’ë§Œì´ ìœ íš¨í•˜ê¸° ë•Œë¬¸ì—, stringì„ keyof Të¡œ ë°”ê¾¸ë©´ ëœë‹¤.
     function pluck<T>(record: T[], key: keyof T) {
       return record.map((r) => r[key]);
     }

     // ê·¸ëŸ°ë° keyì˜ ê°’ìœ¼ë¡œ í•˜ë‚˜ì˜ ë¬¸ìì—´ì„ ë„£ê²Œ ë˜ë©´, ê·¸ ë²”ìœ„ê°€ ë„ˆë¬´ ë„“ì–´ì„œ ì ì ˆí•œ íƒ€ì…ì´ë¼ê³  ë³´ê¸° ì–´ë µìŠµë‹ˆë‹¤.
     declare let albums: Album[];
     const releaseDates = pluck(albums, 'releaseDate'); // Type is (string | Date)[]

     // releaseDatesì˜ íƒ€ì…ì€ (string | Date)[]ê°€ ì•„ë‹ˆë¼ Date[]ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
     // keyof TëŠ” stringì— ë¹„í•˜ë©´ í›¨ì”¬ ë²”ìœ„ê°€ ì¢ê¸°ëŠ” í•˜ì§€ë§Œ ê·¸ëŒ€ë¡œ ì—¬ì „íˆ ë„“ìŠµë‹ˆë‹¤.

     // ë”°ë¼ì„œ ë²”ìœ„ë¥¼ ë” ì¢íˆê¸° ìœ„í•´ì„œ, keyof Tì˜ ë¶€ë¶„ ì§‘í•©ìœ¼ë¡œ ë‘ ë²ˆì§¸ ì œë„ˆë¦­ ë§¤ê°œë³€ìˆ˜ë¥¼ ë„ì…í•´ì•¼ í•©ë‹ˆë‹¤.
     function pluck<T, K extends keyof T>(record: T[], key: K): T[K][] {
       return record.map((r) => r[key]);
     }

     declare let albums: Album[];
     pluck(albums, 'releaseDate'); // Type is Date[]
     pluck(albums, 'artist'); // Type is string[]
     pluck(albums, 'recordingType'); // Type is RecordingType[]
     pluck(albums, 'recordingDate');
     // ~~~~~~~~~~~~~~~ Argument of type '"recordingDate"' is not
     //                 assignable to parameter of type ...
     ```

### ìš”ì•½

- â€˜ë¬¸ìì—´ì„ ë‚¨ë°œí•˜ì—¬ ì„ ì–¸ëœâ€™ ì½”ë“œë¥¼ í”¼í•©ì‹œë‹¤. ëª¨ë“  ë¬¸ìì—´ì„ í• ë‹¹í•  ìˆ˜ ìˆëŠ” string íƒ€ì…ë³´ë‹¤ëŠ” ë” êµ¬ì²´ì ì¸ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
- ë³€ìˆ˜ì˜ ë²”ìœ„ë¥¼ ë³´ë‹¤ ì •í™•í•˜ê²Œ í‘œí˜„í•˜ê³  ì‹¶ë‹¤ë©´ string íƒ€ì…ë³´ë‹¤ëŠ” ë¬¸ìì—´ ë¦¬í„°ëŸ´ íƒ€ì…ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤. íƒ€ì… ì²´í¬ë¥¼ ë” ì—„ê²©íˆ í•  ìˆ˜ ìˆê³  ìƒì‚°ì„±ì„ í–¥ìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
- ê°ì²´ì˜ ì†ì„± ì´ë¦„ì„ í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ì„ ë•ŒëŠ” stringë³´ë‹¤ keyof Të¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

# ì•„ì´í…œ 34 ë¶€ì •í™•í•œ íƒ€ì…ë³´ë‹¤ëŠ” ë¯¸ì™„ì„± íƒ€ì…ì„ ì‚¬ìš©í•˜ê¸°

```tsx
interface Point {
  type: 'Point';
  coordinates: number[];
}
interface LineString {
  type: 'LineString';
  coordinates: number[][];
}
interface Polygon {
  type: 'Polygon';
  coordinates: number[][][];
}

// ê°ê° ë‹¤ë¥¸ í˜•íƒœì˜ ì¢Œí‘œ ë°°ì—´ì„ ê°€ì§€ëŠ” ëª‡ ê°€ì§€ íƒ€ì… ì¤‘ í•˜ë‚˜ê°€ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
type Geometry = Point | LineString | Polygon; // Also several others
```

- í° ë¬¸ì œëŠ” ì—†ì§€ë§Œ ì¢Œí‘œì— ì“°ì´ëŠ” number[]ê°€ ì•½ê°„ ì¶”ìƒì ì…ë‹ˆë‹¤.
- ì—¬ê¸°ì„œ number[]ëŠ” ê²½ë„ì™€ ìœ„ë„ë¥¼ ë‚˜íƒ€ë‚´ë¯€ë¡œ íŠœí”Œ íƒ€ì…ìœ¼ë¡œ ì„ ì–¸í•˜ëŠ” ê²Œ ë‚«ìŠµë‹ˆë‹¤.

```tsx
type GeoPosition = [number, number];
interface Point {
  type: 'Point';
  coordinates: GeoPosition;
}
// Etc.
```

- ì½”ë“œì—ëŠ” ìœ„ë„ì™€ ê²½ë„ë§Œì„ ëª…ì‹œí–ˆì§€ë§Œ, GeoJSONì˜ ìœ„ì¹˜ ì •ë³´ì—ëŠ” ì„¸ ë²ˆì§¸ ìš”ì†Œì¸ ê³ ë„ê°€ ìˆì„ ìˆ˜ ìˆê³  ë˜ ë‹¤ë¥¸ ì •ë³´ê°€ ìˆì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
- ë§µë°•ìŠ¤(Mapbox) ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ìˆ˜ë§ì€ ê¸°ê¸°ì—ì„œ ì§€ë„ ê¸°ëŠ¥ì˜ í˜•íƒœë¥¼ ê²°ì •í•©ë‹ˆë‹¤. ë‹¤ìŒì€ ì´ëŸ° ë™ì‘ì„ ëª¨ë¸ë§í•´ ë³¼ ìˆ˜ ìˆëŠ” ì…ë ¥ê°’ì˜ ì „ì²´ ì¢…ë¥˜ì…ë‹ˆë‹¤.
  1. ëª¨ë‘ í—ˆìš©
  2. ë¬¸ìì—´, ìˆ«ì, ë°°ì—´ í—ˆìš©
  3. ë¬¸ìì—´, ìˆ«ì, ì•Œë ¤ì§„ í•¨ìˆ˜ ì´ë¦„ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ë°°ì—´ í—ˆìš©
  4. ê° í•¨ìˆ˜ê°€ ë°›ëŠ” ë§¤ê°œë³€ìˆ˜ì˜ ê°œìˆ˜ê°€ ì •í™•í•œì§€ í™•ì¸
  5. ê° í•¨ìˆ˜ê°€ ë°”ë“  ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì´ ì •í™•í•œì§€ í™•ì¸
- ì²˜ìŒì˜ ë‘ ê°œ ì˜µì…˜ì€ ê°„ë‹¨í•©ë‹ˆë‹¤.

```tsx
type Expression1 = any;
type Expression2 = number | string | any[];
```

- í‘œí˜„ì‹ì˜ ìœ íš¨ì„±ì„ ì²´í¬í•˜ëŠ” í…ŒìŠ¤íŠ¸ ì„¸íŠ¸ë¥¼ ë„ì…í•´ ë³´ê² ìŠµë‹ˆë‹¤.

```tsx
const tests: Expression2[] = [
  10,
  'red',
  true,
  // ~~~ Type 'true' is not assignable to type 'Expression2'
  ['+', 10, 5],
  ['case', ['>', 20, 10], 'red', 'blue', 'green'], // Too many values
  ['**', 2, 31], // Should be an error: no "**" function
  ['rgb', 255, 128, 64],
  ['rgb', 255, 0, 127, 0], // Too many values
];

// ì •ë°€ë„ë¥¼ í•œ ë‹¨ê³„ ë” ëŒì–´ì˜¬ë¦¬ê¸° ìœ„í•´ì„œ íŠœí”Œì˜ ì²« ë²ˆì§¸ ìš”ì†Œì— ë¬¸ìì—´ ë¦¬í„°ëŸ´ íƒ€ì…ì˜ ìœ ë‹ˆì˜¨ì„ ì‚¬ìš©í•´ë³´ê² ìŠµë‹ˆë‹¤.
type Expression1 = any;
type Expression2 = number | string | any[];
type FnName = '+' | '-' | '*' | '/' | '>' | '<' | 'case' | 'rgb';
type CallExpression = [FnName, ...any[]];
type Expression3 = number | string | CallExpression;

const tests: Expression3[] = [
  10,
  'red',
  true,
  // ~~~ Type 'true' is not assignable to type 'Expression3'
  ['+', 10, 5],
  ['case', ['>', 20, 10], 'red', 'blue', 'green'],
  ['**', 2, 31],
  // ~~~~~~~~~~~ Type '"**"' is not assignable to type 'FnName'
  ['rgb', 255, 128, 64],
];

// ê³ ì • ê¸¸ì´ ë°°ì—´ì€ íŠœí”Œ íƒ€ì…ìœ¼ë¡œ ê°€ì¥ ê°„ë‹¨íˆ í‘œí˜„í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì—,
// ì–´ìƒ‰í•´ ë³´ì¼ ìˆ˜ëŠ” ìˆì§€ë§Œ ë‹¤ìŒ ì½”ë“œì²˜ëŸ¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
type Expression4 = number | string | CallExpression;

type CallExpression = MathCall | CaseCall | RGBCall;

interface MathCall {
  0: '+' | '-' | '/' | '*' | '>' | '<';
  1: Expression4;
  2: Expression4;
  length: 3;
}

interface CaseCall {
  0: 'case';
  1: Expression4;
  2: Expression4;
  3: Expression4;
  length: 4 | 6 | 8 | 10 | 12 | 14 | 16; // etc.
}

interface RGBCall {
  0: 'rgb';
  1: Expression4;
  2: Expression4;
  3: Expression4;
  length: 4;
}

// ì´ì œ ë¬´íš¨í•œ í‘œí˜„ì‹ì—ì„œ ì „ë¶€ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.
// ì´ ì½”ë“œì—ì„œëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•´ì„œ "ì§ìˆ˜ ê¸¸ì´ì˜ ë°°ì—´" ê°™ì€ ê²ƒì„ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
// ê·¸ëŸ¬ë‚˜ ì˜¤ë¥˜ê°€ ë‚˜ë©´ ì—‰ëš±í•œ ë©”ì„¸ì§€ë¥¼ ì¶œë ¥í•˜ë©°, **ì— ëŒ€í•œ ì˜¤ë¥˜ëŠ” ì˜¤íˆë ¤ ì´ì „ë³»ë³´ë‹¤ ë©”ì„¸ì§€ê°€ ë¶€ì •í™•í•´ì§‘ë‹ˆë‹¤.
// íƒ€ì… ì •ë³´ê°€ ë” ì •ë°€í•´ì¡Œì§€ë§Œ ê²°ê³¼ì ìœ¼ë¡œ ì´ì „ ë²„ì „ë³´ë‹¤ ê°œì„ ë˜ì—ˆë‹¤ê³  ë³´ê¸°ëŠ” ì–´ë µìŠµë‹ˆë‹¤.
const tests: Expression4[] = [
  10,
  'red',
  true,
  // ~~~ Type 'true' is not assignable to type 'Expression4'
  ['+', 10, 5],
  ['case', ['>', 20, 10], 'red', 'blue', 'green'],
  // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  //  Type '["case", [">", ...], ...]' is not assignable to type 'string'
  ['**', 2, 31],
  // ~~~~~~~~~~~~ Type '["**", number, number]' is not assignable to type 'string
  ['rgb', 255, 128, 64],
  ['rgb', 255, 128, 64, 73],
  // ~~~~~~~~~~~~~~~~~~~~~~~~ Type '["rgb", number, number, number, number]'
  //                          is not assignable to type 'string'
];

// íƒ€ì… ì„ ì–¸ì˜ ë³µì¡ì„±ìœ¼ë¡œ ì¸í•´ ë²„ê·¸ê°€ ë°œìƒí•  ê°€ëŠ¥ì„±ë„ ë†’ì•„ì¡ŒìŠµë‹ˆë‹¤.
// Expression4ëŠ” ëª¨ë“  ìˆ˜í•™ ì—°ì‚°ìì— ë‘ ê°œì˜ ë§¤ê°œë³€ìˆ˜ê°€ í•„ìš”í•˜ì§€ë§Œ, ë§µë°•ìŠ¤ í‘œí˜„ì‹ì—ì„œëŠ” +ì™€ *ê°€ ë” ë§ì€ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
const okExpressions: Expression4[] = [
  ['-', 12],
  // ~~~~~~~~~ Type '["-", number]' is not assignable to type 'string'
  ['+', 1, 2, 3],
  // ~~~~~~~~~~~~~~ Type '["+", number, ...]' is not assignable to type 'string'
  ['*', 2, 3, 4],
  // ~~~~~~~~~~~~~~ Type '["*", number, ...]' is not assignable to type 'string'
];
```

- ì½”ë“œë¥¼ ë” ì •ë°€í•˜ê²Œ ë§Œë“œë ¤ë˜ ì‹œë„ê°€ ë„ˆë¬´ ê³¼í–ˆê³  ê·¸ë¡œ ì¸í•´ ì½”ë“œê°€ ì˜¤íˆë ¤ ë” ë¶€ì •í•™í•´ì¡ŒìŠµë‹ˆë‹¤.
- ì´ë ‡ê²Œ ë¶€ì •í™•í•¨ì„ ë°”ë¡œì¡ëŠ” ë°©ë²•ì„ ì“°ëŠ” ëŒ€ì‹ , í…ŒìŠ¤íŠ¸ ì„¸íŠ¸ë¥¼ ì¶”ê°€í•˜ì—¬ ë†“ì¹œ ë¶€ë¶„ì´ ì—†ëŠ”ì§€ í™•ì¸í•´ë„ ë©ë‹ˆë‹¤.

### ìš”ì•½

- íƒ€ì… ì•ˆì „ì„±ì—ì„œ ë¶ˆê½¤í•œ ê³¨ì§œê¸°ëŠ” í”¼í•´ì•¼ í•©ë‹ˆë‹¤. íƒ€ì…ì´ ì—†ëŠ” ê²ƒë³´ë‹¤ ì˜ëª»ëœ ê²Œ ë” ë‚˜ì©ë‹ˆë‹¤.
- ì •í™•í•˜ê²Œ íƒ€ì…ì„ ëª¨ë¸ë§í•  ìˆ˜ ì—†ë‹¤ë©´, ë¶€ì •í™•í•˜ê²Œ ëª¨ë¸ë§í•˜ì§€ ë§ì•„ì•¼ í•©ë‹ˆë‹¤. ë˜í•œ anyì™€ unknownì„ êµ¬ë³„í•´ì„œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
- íƒ€ì… ì •ë³´ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ë§Œë“¤ìˆ˜ë¡ ì˜¤ë¥˜ ë©”ì‹œì§€ì™€ ìë™ ì™„ì„± ê¸°ëŠ¥ì— ì£¼ì˜ë¥¼ ê¸°ìš¸ì—¬ì•¼ í•©ë‹ˆë‹¤. ì •í™•ë„ë¿ë§Œ ì•„ë‹ˆë¼ ê°œë°œ ê²½í—˜ê³¼ë„ ê´€ë ¨ë©ë‹ˆë‹¤.

# ì•„ì´í…œ 35 ë°ì´í„°ê°€ ì•„ë‹Œ, APIì™€ ëª…ì„¸ë¥¼ ë³´ê³  íƒ€ì… ë§Œë“¤ê¸°

- íŒŒì¼ í˜•ì‹, API, ëª…ì„¸(specification) ë“± ìš°ë¦¬ê°€ ë‹¤ë£¨ëŠ” íƒ€ì… ì¤‘ ìµœì†Œí•œ ëª‡ ê°œëŠ” í”„ë¡œì íŠ¸ ì™¸ë¶€ì—ì„œ ë¹„ë¡¯ëœ ê²ƒì…ë‹ˆë‹¤.
- ëª…ì„¸ë¥¼ ì°¸ê³ í•´ íƒ€ì…ì„ ìƒì„±í•˜ë©´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ì‚¬ìš©ìê°€ ì‹¤ìˆ˜ë¥¼ ì¤„ì¼ ìˆ˜ ìˆê²Œ ë„ì™€ì¤ë‹ˆë‹¤.
- ë°˜ë©´ì— ì˜ˆì‹œ ë°ì´í„°ë¥¼ ì°¸ê³ í•´ íƒ€ì…ì„ ìƒì„±í•˜ë©´ ëˆˆì•ì— ìˆëŠ” ë°ì´í„°ë“¤ë§Œ ê³ ë ¤í•˜ê²Œ ë˜ë¯€ë¡œ ì˜ˆê¸°ì¹˜ ì•Šì€ ê³³ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```tsx
interface BoundingBox {
  lat: [number, number];
  lng: [number, number];
}

type GeoJSONFeature = any;

// GeoJSONFeature íƒ€ì…ì´ ëª…ì‹œì ìœ¼ë¡œ ì •ì˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.
// ì§ì ‘ ì‘ì„±í•´ ë³¼ìˆ˜ë„ ìˆì§€ë§Œ, ê³µì‹ JSON ëª…ì„¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ë” ë‚«ìŠµë‹ˆë‹¤.
function calculateBoundingBox(f: GeoJSONFeature): BoundingBox | null {
  let box: BoundingBox | null = null;

  const helper = (coords: any[]) => {
    // ...
  };

  const { geometry } = f;
  if (geometry) {
    helper(geometry.coordinates);
  }

  return box;
}
```

```tsx
// requires node modules: @types/geojson

interface BoundingBox {
  lat: [number, number];
  lng: [number, number];
}
import { Feature } from 'geojson';

// GeoJSON ì„ ì–¸ì„ ë„£ëŠ” ìˆœê°„, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤.
function calculateBoundingBox(f: Feature): BoundingBox | null {
  let box: BoundingBox | null = null;

  const helper = (coords: any[]) => {
    // ...
  };

  const { geometry } = f;
  if (geometry) {
    // geometryì— coordinates ì†ì„±ì´ ìˆë‹¤ê³  ê°€ì •í•œ ê²Œ ë¬¸ì œì…ë‹ˆë‹¤.
    // GeoJSONì€ ë‹¤ì–‘í•œ ë„í˜•ì˜ ëª¨ìŒì¸ GeometryCollectionì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.
    // ë‹¤ë¥¸ ë„í˜• íƒ€ì…ë“¤ê³¼ ë‹¤ë¥´ê²Œ GeometryCollectionì—ëŠ” coordinates ì†ì„±ì´ ì—†ìŠµë‹ˆë‹¤.
    helper(geometry.coordinates);
    // ~~~~~~~~~~~
    // Property 'coordinates' does not exist on type 'Geometry'
    //   Property 'coordinates' does not exist on type
    //   'GeometryCollection'
  }

  return box;
}
```

- ì´ ì˜¤ë¥˜ë¥¼ ê³ ì¹˜ëŠ” í•œ ê°€ì§€ ë°©ë²•ì€ ë‹¤ìŒ ì½”ë“œì²˜ëŸ¼ `GeometryCollection` ì„ ëª…ì‹œì ìœ¼ë¡œ ì°¨ë‹¨í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.

```tsx
const { geometry } = f;

if (geometry) {
  if (geometry.type === 'GeometryCollection') {
    throw new Error('GeometryCollections are not supported.');
  }
  helper(geometry.coordinates); // OK
}

// ê·¸ëŸ¬ë‚˜ GeometryCollection íƒ€ì…ì„ ì°¨ë‹¨í•˜ê¸°ë³´ë‹¤ëŠ” ëª¨ë“  íƒ€ì…ì„ ì§€ì›í•˜ëŠ” ê²ƒì´ ë” ì¢‹ì€ ë°©ë²•ì´ë‹¤.
const geometryHelper = (g: Geometry) => {
  if (geometry.type === 'GeometryCollection') {
    geometry.geometries.forEach(geometryHelper);
  } else {
    helper(geometry.coordinates); // OK
  }
};

const { geometry } = f;
if (geometry) {
  geometryHelper(geometry);
}
```

### APIì˜ ëª…ì„¸ë¡œë¶€í„° íƒ€ì…ì„ ìƒì„±í•  ìˆ˜ ìˆë‹¤ë©´ ê·¸ë ‡ê²Œ í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤

- íŠ¹íˆ [GraphQL](https://graphql.org/)ì²˜ëŸ¼ ìì²´ì ìœ¼ë¡œ íƒ€ì…ì´ ì •ì˜ëœ APIì—ì„œ ì˜ ë™ì‘í•©ë‹ˆë‹¤.
- GraphQL APIëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì™€ ë¹„ìŠ·í•œ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ì—¬, ê°€ëŠ¥í•œ ëª¨ë“  ì¿¼ë¦¬ì™€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ëª…ì‹œí•˜ëŠ” ìŠ¤í‚¤ë§ˆë¡œ ì´ë£¨ì–´ì§‘ë‹ˆë‹¤.

```tsx
// GitHub GraphQL APIë¥¼ ì‚¬ìš©í•´ì„œ ì €ì¥ì†Œì— ëŒ€í•œ ì •ë³´ë¥¼ ì–»ëŠ” ì½”ë“œëŠ” ë‹¤ìŒì²˜ëŸ¼ ì‘ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
query {
	repository(owner: "Microsoft", name: "TypeScript") {
		createdAt
		description
	}
}

// ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
{
	"data": {
		"repository": {
			"createdAt": "2014-...",
			"description":
				"TypeScript is ..."
		}
	}
}
```

- GraphQLì˜ ì¥ì ì€ íŠ¹ì • ì¿¼ë¦¬ì— ëŒ€í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ íƒ€ì…ì„ ìƒì„±í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤.

```tsx
// GitHub ì €ì¥ì†Œì—ì„œ ì˜¤í”ˆ ì†ŒìŠ¤ ë¼ì´ì„ ìŠ¤ë¥¼ ì¡°íšŒí•˜ëŠ” ì¿¼ë¦¬ì…ë‹ˆë‹¤.
query getLicense($owner:String!, $name:String!) {
	repository(owner: $owner, name: $name) {
		description
		licenseInfo {
			spdxId
			name
		}
	}
}
```

- GraphQL ì¿¼ë¦¬ë¥¼ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ íƒ€ì…ìœ¼ë¡œ ë³€í™˜í•´ ì£¼ëŠ” ë§ì€ ë„êµ¬ê°€ ì¡´ì¬í•©ë‹ˆë‹¤.
  - ê·¸ì¤‘ í•˜ë‚˜ëŠ” [Apollo](https://www.apollographql.com/docs/react/)ì…ë‹ˆë‹¤.

```tsx
$ apollo client:codegen \
		--endpoint: https://api.github.com/graphql \
		--includes license.graphql \
		--target typescript
Loading Apollo Project
Generating query files with 'typescript' target - wrote 2 files

// ì‹¤í–‰ì˜ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤.
export interface getLicense_repository_licenseInfo {
  __typename: 'License'
  /** Short identifier specified by <https://spdx.org/licenses> */
  spdxId: string | null
  /** The license full name specified by <https://spdx.org/licenses> */
  name: string
}

export interface getLicense_repository {
  __typename: 'Repository'
  /** The description of the repository. */
  description: string | null
  /** The license associated with the repository */
  licenseInfo: getLicense_repository_licenseInfo | null
}

export interface getLicense {
  /** Lookup a given repository by the owner and repository name. */
  repository: getLicense_repository | null
}

export interface getLicenseVariables {
  owner: string
  name: string
}

```

- ì¿¼ë¦¬ ë§¤ê°œë³€ìˆ˜(getLicenseVariables)ì™€ ì‘ë‹µ(getLicense) ëª¨ë‘ ì¸í„°í˜ì´ìŠ¤ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.
- null ê°€ëŠ¥ ì—¬ë¶€ëŠ” ìŠ¤í‚¤ë§ˆë¡œë¶€í„° ì‘ë‹µ ì¸í„°í˜ì´ìŠ¤ë¡œ ë³€í™˜ë˜ì—ˆìŠµë‹ˆë‹¤. repository, description, licenseInfo, spdxId ì†ì„±ì€ nullì´ ê°€ëŠ¥í•œ ë°˜ë©´, nameê³¼ ì¿¼ë¦¬ì— ì‚¬ìš©ëœ ë³€ìˆ˜ë“¤ì€ ê·¸ë ‡ì§€ ì•ŠìŠµë‹ˆë‹¤.
- í¸ì§‘ê¸°ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ ì£¼ì„ì€ JSDocìœ¼ë¡œ ë³€í™˜ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ì£¼ì„ë“¤ì€ GraphQL ìŠ¤í‚¤ë§ˆë¡œë¶€í„° ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

### ìë™ìœ¼ë¡œ ìƒì„±ëœ íƒ€ì… ì •ë³´ëŠ” APIë¥¼ ì •í™•íˆ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤ë‹ˆë‹¤

- ì¿¼ë¦¬ê°€ ë°”ë€ë‹¤ë©´ íƒ€ì…ë„ ìë™ìœ¼ë¡œ ë°”ë€Œë©° ìŠ¤í‚¤ë§ˆê°€ ë°”ë€ë‹¤ë©´ íƒ€ì…ë„ ìë™ìœ¼ë¡œ ë°”ë€ë‹ˆë‹¤.
- íƒ€ì…ì€ ë‹¨ í•˜ë‚˜ì˜ ì›ì²œ ì •ë³´ì¸ GraphQL ìŠ¤í‚¤ë§ˆë¡œë¶€í„° ìƒì„±ë˜ê¸° ë•Œë¬¸ì— íƒ€ì…ê³¼ ì‹¤ì œ ê°’ì´ í•­ìƒ ì¼ì¹˜í•©ë‹ˆë‹¤.

### ìš”ì•½

- ì½”ë“œì˜ êµ¬ì„ êµ¬ì„ê¹Œì§€ íƒ€ì… ì•ˆì „ì„±ì„ ì–»ê¸° ìœ„í•´ API ë˜ëŠ” ë°ì´í„° í˜•ì‹ì— ëŒ€í•œ íƒ€ì… ìƒì„±ì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.
- ë°ì´í„°ì— ë“œëŸ¬ë‚˜ì§€ ì•ŠëŠ” ì˜ˆì™¸ì ì¸ ê²½ìš°ë“¤ì´ ë¬¸ì œê°€ ë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë°ì´í„°ë³´ë‹¤ëŠ” ëª…ì„¸ë¡œë¶€í„° ì½”ë“œë¥¼ ìƒì„±í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.

# ì•„ì´í…œ 36 í•´ë‹¹ ë¶„ì•¼ì˜ ìš©ì–´ë¡œ íƒ€ì… ì´ë¦„ ì§“ê¸°

### ì˜ëª» ì„ íƒí•œ íƒ€ì… ì´ë¦„ì€ ì½”ë“œì˜ ì˜ë„ë¥¼ ì™œê³¡í•˜ê³  ì˜ëª»ëœ ê°œë…ì„ ì‹¬ì–´ì¤€ë‹¤

```tsx
// ë™ë¬¼ë“¤ì˜ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ êµ¬ì¶•í•œë‹¤ê³  ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤.
interface Animal {
  name: string;
  endangered: boolean;
  habitat: string;
}

const leopard: Animal = {
  name: 'Snow Leopard',
  endangered: false,
  habitat: 'tundra',
};
```

- nameì€ ë§¤ìš° ì¼ë°˜ì ì¸ ìš©ì–´ì…ë‹ˆë‹¤. ë™ë¬¼ì˜ í•™ëª…ì¸ì§€ ì¼ë°˜ì ì¸ ëª…ì¹­ì¸ì§€ ì•Œ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
- endangered ì†ì„±ì´ ë©¸ì¢… ìœ„ê¸°ë¥¼ í‘œí˜„í•˜ê¸° ìœ„í•´ boolean íƒ€ì…ì„ ì‚¬ìš©í•œ ê²ƒì´ ì´ìƒí•©ë‹ˆë‹¤. ì´ë¯¸ ë©¸ì¢…ëœ ë™ë¬¼ì„ trueë¡œ í•´ì•¼ í•˜ëŠ”ì§€ íŒë‹¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. endangered ì†ì„±ì˜ ì˜ë„ë¥¼ â€˜ë©¸ì¢… ìœ„ê¸° ë˜ëŠ” ë©¸ì¢…â€™ìœ¼ë¡œ ìƒê°í•œ ê²ƒì¼ì§€ë„ ëª¨ë¦…ë‹ˆë‹¤.
- ì„œì‹ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” habitat ì†ì„±ì€ ë„ˆë¬´ ë²”ìœ„ê°€ ë„“ì€ string íƒ€ì…ì¼ ë¿ë§Œ ì•„ë‹ˆë¼ ì„œì‹ì§€ë¼ëŠ” ëœ» ìì²´ë„ ë¶ˆë¶„ëª…í•˜ê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ ì†ì„±ë“¤ë³´ë‹¤ë„ í›¨ì”¬ ëª¨í˜¸í•©ë‹ˆë‹¤.
- ê°ì²´ì˜ ë³€ìˆ˜ëª…ì´ leopardì´ì§€ë§Œ, name ì†ì„±ì˜ ê°’ì€ â€˜Snow Leopardâ€™ ì…ë‹ˆë‹¤. ê°ì²´ì˜ ì´ë¦„ê³¼ ì†ì„±ì˜ nameì´ ë‹¤ë¥¸ ì˜ë„ë¡œ ì‚¬ìš©ëœ ê²ƒì¸ì§€ ë¶ˆë¶„ëª…í•©ë‹ˆë‹¤.

```tsx
interface Animal {
  commonName: string;
  genus: string;
  species: string;
  status: ConservationStatus;
  climates: KoppenClimate[];
}
type ConservationStatus = 'EX' | 'EW' | 'CR' | 'EN' | 'VU' | 'NT' | 'LC';
type KoppenClimate =
  | 'Af'
  | 'Am'
  | 'As'
  | 'Aw'
  | 'BSh'
  | 'BSk'
  | 'BWh'
  | 'BWk'
  | 'Cfa'
  | 'Cfb'
  | 'Cfc'
  | 'Csa'
  | 'Csb'
  | 'Csc'
  | 'Cwa'
  | 'Cwb'
  | 'Cwc'
  | 'Dfa'
  | 'Dfb'
  | 'Dfc'
  | 'Dfd'
  | 'Dsa'
  | 'Dsb'
  | 'Dsc'
  | 'Dwa'
  | 'Dwb'
  | 'Dwc'
  | 'Dwd'
  | 'EF'
  | 'ET';
const snowLeopard: Animal = {
  commonName: 'Snow Leopard',
  genus: 'Panthera',
  species: 'Uncia',
  status: 'VU', // ì·¨ì•½ì¢…(vulnerable)
  climates: ['ET', 'EF', 'Dfd'], // ê³ ì‚°ëŒ€(alpine) ë˜ëŠ” ì•„ê³ ì‚°ëŒ€(subalpine)
};
```

- ì´ ì½”ë“œëŠ” ë‹¤ìŒ ì„¸ ê°€ì§€ë¥¼ ê°œì„ í–ˆìŠµë‹ˆë‹¤.
  - nameì€ commonName, genus, species ë“± ë” êµ¬ì²´ì ì¸ ìš©ì–´ë¡œ ëŒ€ì²´í–ˆìŠµë‹ˆë‹¤.
  - endangeredëŠ” ë™ë¬¼ ë³´í˜¸ ë“±ê¸‰ì— ëŒ€í•œ IUCNì˜ í‘œì¤€ ë¶„ë¥˜ ì²´ê³„ì¸ ConservationStatus íƒ€ì…ì˜ statusë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.
  - habitatì€ ê¸°í›„ë¥¼ ëœ»í•˜ëŠ” climatesë¡œ ë³€ê²½ë˜ì—ˆìœ¼ë©°, ì¾¨íœ ê¸°í›„ ë¶„ë¥˜ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
- ì½”ë“œë¡œ í‘œí˜„í•˜ê³ ì í•˜ëŠ” ëª¨ë“  ë¶„ì•¼ì—ëŠ” ì£¼ì œë¥¼ ì„¤ëª…í•˜ê¸° ìœ„í•œ ì „ë¬¸ ìš©ì–´ë“¤ì´ ìˆìŠµë‹ˆë‹¤.
  - ìì²´ì ìœ¼ë¡œ ìš©ì–´ë¥¼ ë§Œë“¤ì–´ ë‚´ë ¤ê³  í•˜ì§€ ë§ê³ , **í•´ë‹¹ ë¶„ì•¼ì— ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ìš©ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.**
- íƒ€ì…, ì†ì„±, ë³€ìˆ˜ì— ì´ë¦„ì„ ë¶™ì¼ ë•Œ ëª…ì‹¬í•´ì•¼ í•  ì„¸ ê°€ì§€ ê·œì¹™ì´ ìˆìŠµë‹ˆë‹¤.
  - ë™ì¼í•œ ì˜ë¯¸ë¥¼ ë‚˜íƒ€ë‚¼ ë•ŒëŠ” ê°™ì€ ìš©ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ê¸€ì„ ì“¸ ë•Œë‚˜ ë§ì„ í•  ë•Œ, ê°™ì€ ë‹¨ì–´ë¥¼ ë°˜ë³µí•´ì„œ ì‚¬ìš©í•˜ë©´ ì§€ë£¨í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë™ì˜ì–´(ì˜ë¯¸ê°€ ê°™ì§€ë§Œ ë‹¤ë¥¸ ë‹¨ì–´)ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. **ë™ì˜ì–´ë¥¼ ì‚¬ìš©í•˜ë©´ ê¸€ì„ ì½ì„ ë•ŒëŠ” ì¢‹ì„ ìˆ˜ ìˆì§€ë§Œ, ì½”ë“œì—ì„œëŠ” ì¢‹ì§€ ì•ŠìŠµë‹ˆë‹¤. ì •ë§ë¡œ ì˜ë¯¸ì ìœ¼ë¡œ êµ¬ë¶„ì´ ë˜ì–´ì•¼ í•˜ëŠ” ê²½ìš°ì—ë§Œ ë‹¤ë¥¸ ìš©ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.**
  - data, info, thing, item, object, entity ê°™ì€ ëª¨í˜¸í•˜ê³  ì˜ë¯¸ ì—†ëŠ” ì´ë¦„ì€ í”¼í•´ì•¼ í•©ë‹ˆë‹¤. ë§Œì•½ entity ë¼ëŠ” ìš©ì–´ê°€ í•´ë‹¹ ë¶„ì•¼ì—ì„œ íŠ¹ë³„í•œ ì˜ë¯¸ë¥¼ ê°€ì§„ë‹¤ë©´ ê´œì°®ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ê·€ì°®ë‹¤ê³  ë¬´ì‹¬ì½” ì˜ë¯¸ ì—†ëŠ” ì´ë¦„ì„ ë¶™ì—¬ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.
  - ì´ë¦„ì„ ì§€ì„ ë•ŒëŠ” í¬í•¨ëœ ë‚´ìš©ì´ë‚˜ ê³„ì‚° ë°©ì‹ì´ ì•„ë‹ˆë¼ ë°ì´í„° ìì²´ê°€ ë¬´ì—‡ì¸ì§€ë¥¼ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, INodeList ë³´ë‹¤ëŠ” Directoryê°€ ë” ì˜ë¯¸ìˆëŠ” ì´ë¦„ì…ë‹ˆë‹¤. DirectoryëŠ” êµ¬í˜„ì˜ ì¸¡ë©´ì´ ì•„ë‹ˆë¼ ê°œë…ì˜ ì¸¡ë©´ì—ì„œ ë””ë ‰í„°ë¦¬ë¥¼ ìƒê°í•˜ê²Œ í•©ë‹ˆë‹¤. **ì¢‹ì€ ì´ë¦„ì€ ì¶”ìƒí™”ì˜ ìˆ˜ì¤€ì„ ë†’ì´ê³  ì˜ë„ì¹˜ ì•Šì€ ì¶©ëŒì˜ ìœ„í—˜ì„±ì„ ì¤„ì—¬ ì¤ë‹ˆë‹¤.**

### ìš”ì•½

- ê°€ë…ì„±ì„ ë†’ì´ê³ , ì¶”ìƒí™” ìˆ˜ì¤€ì„ ì˜¬ë¦¬ê¸° ìœ„í•´ì„œ í•´ë‹¹ ë¶„ì•¼ì˜ ìš©ì–´ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
- ê°™ì€ ì˜ë¯¸ì— ë‹¤ë¥¸ ì´ë¦„ì„ ë¶™ì´ë©´ ì•ˆë©ë‹ˆë‹¤. íŠ¹ë³„í•œ ì˜ë¯¸ê°€ ìˆì„ ë•ŒëŠ” ìš©ì–´ë¥¼ êµ¬ë¶„í•´ì•¼ í•©ë‹ˆë‹¤.

# ì•„ì´í…œ 37 ê³µì‹ ëª…ì¹­ì—ëŠ” ìƒí‘œë¥¼ ë¶™ì´ê¸°

### êµ¬ì¡°ì  íƒ€ì´í•‘ì˜ íŠ¹ì„± ë•Œë¬¸ì— ê°€ë” ì½”ë“œê°€ ì´ìƒí•œ ê²°ê³¼ë¥¼ ë‚¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤

```tsx
interface Vector2D {
  x: number;
  y: number;
}

function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x * p.x + p.y * p.y);
}

calculateNorm({ x: 3, y: 4 }); // OK, result is 5

// ì´ ì½”ë“œëŠ” êµ¬ì¡°ì  íƒ€ì´í•‘ ê´€ì ì—ì„œëŠ” ë¬¸ì œê°€ ì—†ê¸°ëŠ” í•˜ì§€ë§Œ, ìˆ˜í•™ì ìœ¼ë¡œ ë”°ì§€ë©´ 2ì°¨ì› ë²¡í„°ë¥¼ ì‚¬ìš©í•´ì•¼ ì´ì¹˜ì— ë§ìŠµë‹ˆë‹¤.
const vec3D = { x: 3, y: 4, z: 1 };
calculateNorm(vec3D); // OK! result is also 5
```

- calculateNorm í•¨ìˆ˜ê°€ 3ì°¨ì› ë²¡í„°ë¥¼ í—ˆìš©í•˜ì§€ ì•Šê²Œ í•˜ë ¤ë©´ ê³µì‹ ëª…ì¹­(nomi-nal typing)ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤.
  - ê³µì‹ ëª…ì¹­ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€, íƒ€ì…ì´ ì•„ë‹ˆë¼ ê°’ì˜ ê´€ì ì—ì„œ Vector2Dë¼ê³  ë§í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.
  - ê³µì‹ ëª…ì¹­ ê°œë…ì„ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ í‰ë‚´ ë‚´ë ¤ë©´ â€˜ìƒí‘œ(brand)â€™ë¥¼ ë¶™ì´ë©´ ë©ë‹ˆë‹¤.

```tsx
interface Vector2D {
  _brand: '2d';
  x: number;
  y: number;
}
function vec2D(x: number, y: number): Vector2D {
  return { x, y, _brand: '2d' };
}
function calculateNorm(p: Vector2D) {
  return Math.sqrt(p.x * p.x + p.y * p.y); // Same as before
}

calculateNorm(vec2D(3, 4)); // OK, returns 5

// ìƒí‘œ(_brand)ë¥¼ ì‚¬ìš©í•´ì„œ calculateNorm í•¨ìˆ˜ê°€ Vector2D íƒ€ì…ë§Œ ë°›ëŠ” ê²ƒì„ ë³´ì¥í•©ë‹ˆë‹¤.
// ê·¸ëŸ¬ë‚˜ vec3D ê°’ì— _brand: '2d'ë¼ê³  ì¶”ê°€í•˜ëŠ” ê²ƒ ê°™ì€ ì•…ì˜ì ì¸ ì‚¬ìš©ì„ ë§‰ì„ ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.
// ë‹¤ë§Œ ë‹¨ìˆœí•œ ì‹¤ìˆ˜ë¥¼ ë°©ì§€í•˜ê¸°ì—ëŠ” ì¶©ë¶„í•©ë‹ˆë‹¤.
const vec3D = { x: 3, y: 4, z: 1 };
calculateNorm(vec3D);
// ~~~~~ Property '_brand' is missing in type...
```

### ìƒí‘œ ê¸°ë²•ì€ íƒ€ì… ì‹œìŠ¤í…œì—ì„œ ë™ì‘í•˜ì§€ë§Œ ëŸ°íƒ€ì„ì— ìƒí‘œë¥¼ ê²€ì‚¬í•˜ëŠ” ê²ƒê³¼ ë™ì¼í•œ íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤

- íƒ€ì… ì‹œìŠ¤í…œì´ê¸° ë•Œë¬¸ì— ëŸ°íƒ€ì„ ì˜¤ë²„í—¤ë“œë¥¼ ì—†ì•¨ ìˆ˜ ìˆê³  ì¶”ê°€ ì†ì„±ì„ ë¶™ì¼ ìˆ˜ ì—†ëŠ” stringì´ë‚˜ number ê°™ì€ ë‚´ì¥ íƒ€ì…ë„ ìƒí‘œí™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```tsx
// ì ˆëŒ€ ê²½ë¡œë¥¼ ì‚¬ìš©í•´ íŒŒì¼ ì‹œìŠ¤í…œì— ì ‘ê·¼í•˜ëŠ” í•¨ìˆ˜ë¥¼ ê°€ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤.
// ëŸ°íƒ€ì„ì—ëŠ” ì ˆëŒ€ ê²½ë¡œ('/')ë¡œ ì‹œì‘í•˜ëŠ”ì§€ ì²´í¬í•˜ê¸° ì‰½ì§€ë§Œ,
// íƒ€ì… ì‹œìŠ¤í…œì—ì„œëŠ” ì ˆëŒ€ ê²½ë¡œë¥¼ íŒë‹¨í•˜ê¸° ì–´ë µê¸° ë•Œë¬¸ì— ìƒí‘œ ê¸°ë²•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.

// string íƒ€ì…ì´ë©´ì„œ _brand ì†ì„±ì„ ê°€ì§€ëŠ” ê°ì²´ë¥¼ ë§Œë“¤ ìˆ˜ëŠ” ì—†ìŠµë‹ˆë‹¤.
type AbsolutePath = string & { _brand: 'abs' };

function listAbsolutePath(path: AbsolutePath) {
  // ...
}

function isAbsolutePath(path: string): path is AbsolutePath {
  return path.startsWith('/');
}

// ë§Œì•½ path ê°’ì´ ì ˆëŒ€ ê²½ë¡œì™€ ìƒëŒ€ ê²½ë¡œ ë‘˜ ë‹¤ ë  ìˆ˜ ìˆë‹¤ë©´,
// íƒ€ì…ì„ ì •ì œí•´ì£¼ëŠ” íƒ€ì… ê°€ë“œë¥¼ ì‚¬ìš©í•´ì„œ ì˜¤ë¥˜ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
function f(path: string) {
  if (isAbsolutePath(path)) {
    listAbsolutePath(path);
  }
  listAbsolutePath(path);
  // ~~~~ Argument of type 'string' is not assignable
  //      to parameter of type 'AbsolutePath'
}
```

### ìƒí‘œ ê¸°ë²•ì€ íƒ€ì… ì‹œìŠ¤í…œ ë‚´ì—ì„œ í‘œí˜„í•  ìˆ˜ ì—†ëŠ” ìˆ˜ë§ì€ ì†ì„±ë“¤ì„ ëª¨ë¸ë§í•˜ëŠ” ë° ì‚¬ìš©ë˜ê¸°ë„ í•©ë‹ˆë‹¤

```tsx
// ëª©ë¡ì—ì„œ í•œ ìš”ì†Œë¥¼ ì°¾ê¸° ìœ„í•´ ì´ì§„ íƒìƒ‰ì„ í•˜ëŠ” ê²½ìš°
function binarySearch<T>(xs: T[], x: T): boolean {
  let low = 0,
    high = xs.length - 1;
  while (high >= low) {
    const mid = low + Math.floor((high - low) / 2);
    const v = xs[mid];
    if (v === x) return true;
    [low, high] = x > v ? [mid + 1, high] : [low, mid - 1];
  }
  return false;
}
```

- ì´ì§„ ê²€ìƒ‰ì€ ì´ë¯¸ ì •ë ¬ëœ ìƒíƒœë¥¼ ê°€ì •í•˜ê¸° ë•Œë¬¸ì—, ëª©ë¡ì´ ì´ë¯¸ ì •ë ¬ë˜ì–´ ìˆë‹¤ë©´ ë¬¸ì œê°€ ì—†ìŠµë‹ˆë‹¤.
  - í•˜ì§€ë§Œ ëª©ë¡ì´ ì •ë ¬ë˜ì–´ ìˆì§€ ì•Šë‹¤ë©´ ì˜ëª»ëœ ê²°ê³¼ê°€ ë‚˜ì˜µë‹ˆë‹¤.
  - íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ íƒ€ì… ì‹œìŠ¤í…œì—ì„œëŠ” ëª©ë¡ì´ ì •ë ¬ë˜ì–´ ìˆë‹¤ëŠ” ì˜ë„ë¥¼ í‘œí˜„í•˜ê¸° ì–´ë µìŠµë‹ˆë‹¤.

```tsx
type SortedList<T> = T[] & { _brand: 'sorted' };

function isSorted<T>(xs: T[]): xs is SortedList<T> {
  for (let i = 1; i < xs.length; i++) {
    if (xs[i] > xs[i - 1]) {
      return false;
    }
  }
  return true;
}

function binarySearch<T>(xs: SortedList<T>, x: T): boolean {
  // ...
}
```

- binarySearchë¥¼ í˜¸ì¶œí•˜ë ¤ë©´, ì •ë ¬ë˜ì—ˆë‹¤ëŠ” ìƒí‘œê°€ ë¶™ì€ SortedList íƒ€ì…ì˜ ê°’ì„ ì‚¬ìš©í•˜ê±°ë‚˜ isSortedë¥¼ í˜¸ì¶œí•˜ì—¬ ì •ë ¬ë˜ì—ˆìŒì„ ì¦ëª…í•´ì•¼ í•©ë‹ˆë‹¤.
- isSortedì—ì„œ ëª©ë¡ ì „ì²´ë¥¼ ë£¨í”„ ë„ëŠ” ê²ƒì´ íš¨ìœ¨ì ì¸ ë°©ë²•ì€ ì•„ë‹ˆì§€ë§Œ ì ì–´ë„ ì•ˆì „ì„±ì€ í™•ë³´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

### number íƒ€ì…ì—ë„ ìƒí‘œë¥¼ ë¶™ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤

```tsx
type Meters = number & { _brand: 'meters' };
type Seconds = number & { _brand: 'seconds' };

const meters = (m: number) => m as Meters;
const seconds = (s: number) => s as Seconds;

const oneKm = meters(1000); // Type is Meters
const oneMin = seconds(60); // Type is Seconds

// number íƒ€ì…ì— ìƒí‘œë¥¼ ë¶™ì—¬ë„ ì‚°ìˆ  ì—°ì‚° í›„ì—ëŠ” ìƒí‘œê°€ ì—†ì–´ì§€ê¸° ë•Œë¬¸ì—
// ì‹¤ì œë¡œ ì‚¬ìš©í•˜ê¸°ì—ëŠ” ë¬´ë¦¬ê°€ ìˆìŠµë‹ˆë‹¤.
const tenKm = oneKm * 10; // Type is number
const v = oneKm / oneMin; // Type is number

// ê·¸ëŸ¬ë‚˜ ì½”ë“œì— ì—¬ëŸ¬ ë‹¨ìœ„ê°€ í˜¼í•©ëœ ë§ì€ ìˆ˜ì˜ ìˆ«ìê°€ ë“¤ì–´ ìˆëŠ” ê²½ìš°,
// ìˆ«ìì˜ ë‹¨ìœ„ë¥¼ ë¬¸ì„œí™”í•˜ëŠ” ê´œì°®ì€ ë°©ë²•ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```

### ìš”ì•½

- íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” êµ¬ì¡°ì  íƒ€ì´í•‘(ë• íƒ€ì´í•‘)ì„ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì—, ê°’ì„ ì„¸ë°€í•˜ê²Œ êµ¬ë¶„í•˜ì§€ ëª»í•˜ëŠ” ê²½ìš°ê°€ ìˆìŠµë‹ˆë‹¤. ê°’ì„ êµ¬ë¶„í•˜ê¸° ìœ„í•´ ê³µì‹ ëª…ì¹­ì´ í•„ìš”í•˜ë‹¤ë©´ ìƒí‘œë¥¼ ë¶™ì´ëŠ” ê²ƒì„ ê³ ë ¤í•´ì•¼ í•©ë‹ˆë‹¤.
- ìƒí‘œ ê¸°ë²•ì€ íƒ€ì… ì‹œìŠ¤í…œì—ì„œ ë™ì‘í•˜ì§€ë§Œ ëŸ°íƒ€ì„ì— ìƒí‘œë¥¼ ê²€ì‚¬í•˜ëŠ” ê²ƒê³¼ ë™ì¼í•œ íš¨ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
