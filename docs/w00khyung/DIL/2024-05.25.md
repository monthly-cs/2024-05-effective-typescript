# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-05-25
> ì‘ì„±ì: w00khyung

---

## ì•„ì´í…œ 24 ì¼ê´€ì„± ìˆëŠ” ë³„ì¹­ ì‚¬ìš©í•˜ê¸°

```tsx
const borough = { name: 'Brooklyn', location: [40.688, -73.979] }
const loc = borough.location

// ë³„ì¹­ì˜ ê°’ì„ ë³€ê²½í•˜ë©´ ì›ë˜ ì†ì„±ê°’ì—ì„œë„ ë³€ê²½ëœë‹¤.
> loc[0] = 0;
> borough.location
[0, -73.979]
```

### ë³„ì¹­ì„ ë‚¨ë°œí•´ì„œ ì‚¬ìš©í•˜ë©´ ì œì–´ íë¦„ì„ ë¶„ì„í•˜ê¸° ì–´ë µë‹¤.

```tsx
interface Coordinate {
  x: number
  y: number
}

interface BoundingBox {
  x: [number, number]
  y: [number, number]
}

interface Polygon {
  exterior: Coordinate[]
  holes: Coordinate[][]
  bbox?: BoundingBox
}

// bbox ì†ì„±ì„ ì‚¬ìš©í•˜ë©´ ì–´ë–¤ ì ì´ ë‹¤ê°í˜•ì— í¬í•¨ë˜ëŠ”ì§€ ë¹ ë¥´ê²Œ ì²´í¬í•  ìˆ˜ ìˆë‹¤.
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
	// ğŸ¤” ì˜ ë™ì‘í•˜ì§€ë§Œ(íƒ€ì… ì²´í¬ë„ í†µê³¼) ë°˜ë³µë˜ëŠ” ë¶€ë¶„ì´ ì¡´ì¬í•œë‹¤.
  if (**polygon.bbox**) {
    if (pt.x < polygon.bbox.x[0] || pt.x > polygon.bbox.x[1] || pt.y < polygon.bbox.y[1] || pt.y > polygon.bbox.y[1]) {
      return false
    }
  }

  // ... more complex check
}

// ì¤‘ë³µì„ ì¤„ì´ê¸° ìœ„í•´ ì„ì‹œ ë³€ìˆ˜ë¥¼ ë½‘ì•„ëƒˆë‹¤.
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox
  if (polygon.bbox) {
    if (
      pt.x < box.x[0] ||
      // ğŸ¤” ì²« ë²ˆì§¸ ì˜ˆì œì—ì„œëŠ” ì˜ ë™ì‘í–ˆë˜ ì œì–´ íë¦„ ë¶„ì„ì„ ë°©í•´í•´ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
      pt.x > box.x[1] ||
      //     ~~~                ~~~  Object is possibly 'undefined'
      pt.y < box.y[1] ||
      pt.y > box.y[1]
    ) {
      //     ~~~                ~~~  Object is possibly 'undefined'
      return false
    }
  }
  // ...
}

// ì•„ë˜ì™€ ê°™ì´ ë™ì‘í–ˆë‹¤.
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  polygon.bbox // Type is BoundingBox | undefined
  const box = polygon.bbox
  box // Type is BoundingBox | undefined
  if (polygon.bbox) {
    polygon.bbox // Type is BoundingBox
    box // Type is BoundingBox | undefined
  }
}

// âœ… ìœ„ ì˜¤ë¥˜ëŠ” "ë³„ì¹­ì„ ì¼ê´€ì„± ìˆê²Œ ì‚¬ìš©í•œë‹¤"ëŠ” ê¸°ë³¸ ì›ì¹™(golden rule)ì„ ì§€í‚¤ë©´ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.
function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox
  if (box) {
    if (pt.x < box.x[0] || pt.x > box.x[1] || pt.y < box.y[1] || pt.y > box.y[1]) {
      // OK
      return false
    }
  }
  // ...
}

function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
	// ê°ì²´ ë¹„êµ¬ì¡°í™”ë¥¼ ì´ìš©í•˜ë©´ ë³´ë‹¤ ê°„ê²°í•œ ë¬¸ë²•ìœ¼ë¡œ ì¼ê´€ëœ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
	// ê°ì²´ ë¹„êµ¬ì¡°í™”ë¥¼ ì´ìš©í•  ë•ŒëŠ” ë‘ ê°€ì§€ë¥¼ ì£¼ì˜í•´ì•¼ í•œë‹¤.
	// 1. ì„ íƒì  ì†ì„±ì¼ ê²½ìš° ì†ì„± ì²´í¬ê°€ ë” í•„ìš”í•˜ë‹¤.
	// 2. bboxì—ëŠ” ì„ íƒì  ì†ì„±ì´ ì í•©í–ˆì§€ë§Œ holesëŠ” ê·¸ë ‡ì§€ ì•Šë‹¤. holesê°€ ì„ íƒì ì´ë¼ë©´, ê°’ì´ ì—†ê±°ë‚˜ ë¹ˆ ë°°ì—´([])ì´ì—ˆì„ê±°ë‹¤.
	// ì°¨ì´ê°€ ì—†ëŠ”ë° ì´ë¦„ì„ êµ¬ë³„í•œ ê²ƒì´ë‹¤. ë¹ˆ ë°°ì—´ì„ 'holes ì—†ìŒ'ì„ ë‚˜íƒ€ë‚´ëŠ” ì¢‹ì€ ë°©ë²•ì´ë‹¤.
  const { bbox } = polygon
  if (bbox) {
    const { x, y } = bbox
    if (pt.x < x[0] || pt.x > x[1] || pt.y < x[0] || pt.y > y[1]) {
      return false
    }
  }
  // ...
}
```

### ë³„ì¹­ì€ íƒ€ì… ì²´ì»¤ë¿ë§Œ ì•„ë‹ˆë¼ ëŸ°íƒ€ì„ì—ë„ í˜¼ë™ì„ ì•¼ê¸°í•  ìˆ˜ ìˆë‹¤

```tsx
const { bbox } = polygon;
if (!bbox) {
  calculatePolygonBbox(polygon); // Fills in polygon.bbox
  // Now polygon.bbox and bbox refer to different values!
}
```

### ê°ì²´ ì†ì„±ì—ì„œëŠ” ì œì–´ íë¦„ ë¶„ì„ì„ ì£¼ì˜í•´ì„œ ì‚¬ìš©í•´ì•¼ í•œë‹¤

```tsx
function fn(p: Polygon) {
  /* ... */
}

polygon.bbox; // Type is BoundingBox | undefined
if (polygon.bbox) {
  polygon.bbox; // Type is BoundingBox
  // fn(polygon) í˜¸ì¶œì€ polygon.bboxë¥¼ ì œê±°í•  ê°€ëŠ¥ì„±ì´ ìˆìœ¼ë¯€ë¡œ íƒ€ì…ì„ Bounding | undefinedë¡œ ë˜ëŒë¦¬ëŠ” ê²ƒì´ ì•ˆì „í•˜ë‹¤.
  // ê·¸ëŸ¬ë‚˜ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œë§ˆë‹¤ ì†ì„± ì²´í¬ë¥¼ ë°˜ë³µí•´ì•¼ í•˜ê¸° ë•Œë¬¸ì— ì¢‹ì§€ ì•Šë‹¤.
  // ê·¸ë˜ì„œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” í•¨ìˆ˜ê°€ íƒ€ì… ì •ì œë¥¼ ë¬´íš¨í™”í•˜ì§€ ì•ŠëŠ”ë‹¤ê³  ê°€ì •í•œë‹¤.
  fn(polygon);
  polygon.bbox; // Type is still BoundingBox
}
```

### ìš”ì•½

- ë³„ì¹­ì€ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ íƒ€ì…ì„ ì¢íˆëŠ” ê²ƒì„ ë°©í•´í•œë‹¤. ë”°ë¼ì„œ ë³€ìˆ˜ì— ë³„ì¹­ì„ ì‚¬ìš©í•  ë•ŒëŠ” ì¼ê´€ë˜ê²Œ ì‚¬ìš©í•´ì•¼ í•œë‹¤.
- ë¹„êµ¬ì¡°í™” ë¬¸ë²•ì„ ì‚¬ìš©í•´ì„œ ì¼ê´€ëœ ì´ë¦„ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
- í•¨ìˆ˜ í˜¸ì¶œì´ ê°ì²´ ì†ì„±ì˜ íƒ€ì… ì •ì œë¥¼ ë¬´íš¨í™”í•  ìˆ˜ ìˆë‹¤ëŠ” ì ì„ ì£¼ì˜í•´ì•¼ í•œë‹¤. ì†ì„±ë³´ë‹¤ ì§€ì—­ ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë©´ íƒ€ì… ì •ì œë¥¼ ë¯¿ì„ ìˆ˜ ìˆë‹¤.

## ì•„ì´í…œ 25 ë¹„ë™ê¸° ì½”ë“œì—ëŠ” ì½œë°± ëŒ€ì‹  async í•¨ìˆ˜ ì‚¬ìš©í•˜ê¸°

### ì½œë°± ì§€ì˜¥(callback hell)

```tsx
function fetchURL(url: string, cb: (response: string) => void) {
  cb(url);
}
const url1 = '1';
const url2 = '2';
const url3 = '3';
// END
fetchURL(url1, function (response1) {
  fetchURL(url2, function (response2) {
    fetchURL(url3, function (response3) {
      // ...
      console.log(1);
    });
    console.log(2);
  });
  console.log(3);
});
console.log(4);

// ğŸ¤” ì‹¤í–‰ì˜ ìˆœì„œê°€ ì½”ë“œì˜ ìˆœì„œì™€ ë°˜ëŒ€ë‹¤. ì´ëŸ¬í•œ ì½œë°±ì´ ì¤‘ì²©ëœ ì½”ë“œëŠ” ì§ê´€ì ìœ¼ë¡œ ì´í•´í•˜ê¸° ì–´ë µë‹¤.
// Logs:
// 4
// 3
// 2
// 1
```

### í”„ë¡œë¯¸ìŠ¤(Promise) (ES2015)

```tsx
const page1Promise = fetch(url1);
page1Promise
  .then((response1) => {
    return fetch(url2);
  })
  .then((response2) => {
    return fetch(url3);
  })
  .then((response3) => {
    // ...
  })
  .catch((error) => {
    // ...
  });
```

### async/await (ES2017)

```tsx
// await í‚¤ì›Œë“œëŠ” ê°ê°ì˜ í”„ë¡œë¯¸ìŠ¤ê°€ ì²˜ë¦¬(resolve)ë  ë•Œê¹Œì§€ í•¨ìˆ˜ì˜ ì‹¤í–‰ì„ ë©ˆì¶˜ë‹¤.
async function fetchPages() {
  const response1 = await fetch(url1);
  const response2 = await fetch(url2);
  const response3 = await fetch(url3);
  // ...
}

// try/catch êµ¬ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
async function fetchPages() {
  try {
    const response1 = await fetch(url1);
    const response2 = await fetch(url2);
    const response3 = await fetch(url3);
    // ...
  } catch (e) {
    // ...
  }
}
```

- ì½œë°±ë³´ë‹¤ëŠ” í”„ë¡œë¯¸ìŠ¤ê°€ ì½”ë“œë¥¼ ì‘ì„±í•˜ê¸° ì‰½ë‹¤.
- ì½œë°±ë³´ë‹¤ëŠ” í”„ë¡œë¯¸ìŠ¤ê°€ íƒ€ì…ì„ ì¶”ë¡ í•˜ê¸° ì‰½ë‹¤.

```tsx
// ë³‘ë ¬ë¡œ í˜ì´ì§€ë¥¼ ë¡œë“œí•˜ê³  ì‹¶ë‹¤ë©´ Promise.allì„ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
async function fetchPages() {
  const [response1, response2, response3] = await Promise.all([fetch(url1), fetch(url2), fetch(url3)]);
  // ...
}

// ğŸ¤” ì½œë°± ìŠ¤íƒ€ì¼ë¡œ ë™ì¼í•œ ì½”ë“œë¥¼ ì‘ì„±í•˜ë ¤ë©´ ë” ë§ì€ ì½”ë“œì™€ íƒ€ì… êµ¬ë¬¸ì´ í•„ìš”í•˜ë‹¤.
// ì´ ì½”ë“œì— ì˜¤ë¥˜ ì²˜ë¦¬ë¥¼ í¬í•¨í•˜ê±°ë‚˜ Promise.all ê°™ì€ ì¼ë°˜ì ì€ ì½”ë“œë¡œ í™•ì¥í•˜ëŠ” ê²ƒì€ ì‰½ì§€ ì•Šë‹¤.
function fetchPagesCB() {
  let numDone = 0;
  const responses: string[] = [];
  const done = () => {
    const [response1, response2, response3] = responses;
    // ...
  };
  const urls = [url1, url2, url3];
  urls.forEach((url, i) => {
    fetchURL(url, (r) => {
      responses[i] = url;
      numDone++;
      if (numDone === urls.length) done();
    });
  });
}
```

```tsx
// ì…ë ¥ëœ í”„ë¡œë¯¸ìŠ¤ë“¤ ì¤‘ ì²« ë²ˆì§¸ê°€ ì²˜ë¦¬ë  ë•Œ ì™„ë£Œë˜ëŠ” Promise.raceë„ íƒ€ì… ì¶”ë¡ ê³¼ ì˜ ë§ë‹¤.
// Promise.raceë¥¼ ì‚¬ìš©í•˜ì—¬ í”„ë¡œë¯¸ìŠ¤ì— íƒ€ì„ì•„ì›ƒì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì€ í”í•˜ê²Œ ì‚¬ìš©ë˜ëŠ” íŒ¨í„´ì´ë‹¤.
function timeout(millis: number): Promise<never> {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject('timeout'), millis);
  });
}

// ë°˜í™˜ íƒ€ì…ì´ Promise<Response>ë¡œ ì¶”ë¡ ëœë‹¤.
async function fetchWithTimeout(url: string, ms: number) {
  return Promise.race([fetch(url), timeout(ms)]);
}
```

### í”„ë¡œë¯¸ìŠ¤ë¥¼ ìƒì„±í•˜ê¸°ë³´ë‹¤ëŠ” async/awaitë¥¼ ì‚¬ìš©í•˜ê¸°

- ì¼ë°˜ì ìœ¼ë¡œ ë” ê°„ê²°í•˜ê³  ì§ê´€ì ì¸ ì½”ë“œê°€ ëœë‹¤.
- async í•¨ìˆ˜ëŠ” í•­ìƒ í”„ë¡œë¯¸ìŠ¤ë¥¼ ë°˜í™˜í•˜ë„ë¡ ê°•ì œëœë‹¤.

```tsx
// function getNumber(): Promise<number>
async function getNumber() {
  return 42;
}

const getNumber = async () => 42; // Type is () => Promise<number>

// í”„ë¡œë¯¸ìŠ¤ë¥¼ ì§ì ‘ ìƒì„±í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
const getNumber = () => Promise.resolve(42); // Type is () => Promise<number>
```

```tsx
// Don't do this!
// âŒ ìºì‹œëœ ê²½ìš° ì½œë°± í•¨ìˆ˜ê°€ ë™ê¸°ë¡œ í˜¸ì¶œë˜ê¸° ë•Œë¬¸ì— í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê¸° ì–´ë ¤ì›Œì§„ë‹¤.
const _cache: { [url: string]: string } = {}
function fetchWithCache(url: string, callback: (text: string) => void) {
  if (url in _cache) {
    callback(_cache[url])
  } else {
    fetchURL(url, text => {
      _cache[url] = text
      callback(text)
    })
  }
}

let requestStatus: 'loading' | 'success' | 'error'
function getUser(userId: string) {
  fetchWithCache(`/user/${userId}`, profile => {
    requestStatus = 'success'
  })
  requestStatus = 'loading'
}

---

// asyncë¥¼ ë‘ í•¨ìˆ˜ì— ëª¨ë‘ ì‚¬ìš©í•˜ë©´ ì¼ê´€ì ì¸ ë™ì‘ì„ ê°•ì œí•˜ê²Œ ëœë‹¤.
async function fetchWithCache(url: string) {
  if (url in _cache) {
    return _cache[url]
  }
  const response = await fetch(url)
  const text = await response.text()
  _cache[url] = text
  return text
}

let requestStatus: 'loading' | 'success' | 'error'
async function getUser(userId: string) {
  requestStatus = 'loading'
  const profile = await fetchWithCache(`/user/${userId}`)
  requestStatus = 'success'
}

```

### async í•¨ìˆ˜ì—ì„œ í”„ë¡œë¯¸ìŠ¤ë¥¼ ë°˜í™˜í•˜ë©´ ë˜ ë‹¤ë¥¸ í”„ë¡œë¯¸ìŠ¤ë¡œ ë˜í•‘ë˜ì§€ ì•ŠëŠ”ë‹¤.

```tsx
// Function getJSON(url: string): Promise<any>
// ë°˜í™˜ íƒ€ì…ì´ Promise<Promise<T>>ê°€ ì•„ë‹Œ Promise<T>ê°€ ëœë‹¤.
async function getJSON(url: string) {
  const response = await fetch(url);
  const jsonPromise = response.json(); // Type is Promise<any>
  return jsonPromise;
}
```

### ìš”ì•½

- ì½œë°±ë³´ë‹¤ëŠ” í”„ë¡œë¯¸ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²Œ ì½”ë“œ ì‘ì„±ê³¼ íƒ€ì… ì¶”ë¡  ë©´ì—ì„œ ìœ ë¦¬í•˜ë‹¤.
- ê°€ëŠ¥í•˜ë©´ í”„ë¡œë¯¸ìŠ¤ë¥¼ ìƒì„±í•˜ê¸°ë³´ë‹¤ëŠ” asyncì™€ awaitë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤. ê°„ê²°í•˜ê³  ì§ê´€ì ì¸ ì½”ë“œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆê³  ëª¨ë“  ì¢…ë¥˜ì˜ ì˜¤ë¥˜ë¥¼ ì œê±° í•  ìˆ˜ ìˆë‹¤.
- ì–´ë–¤ í•¨ìˆ˜ê°€ í”„ë¡œë¯¸ìŠ¤ë¥¼ ë°˜í™˜í•œë‹¤ë©´ asyncë¡œ ì„ ì–¸í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

## ì•„ì´í…œ 26 íƒ€ì… ì¶”ë¡ ì— ë¬¸ë§¥ì´ ì–´ë–»ê²Œ ì‚¬ìš©ë˜ëŠ”ì§€ ì´í•´í•˜ê¸°

### íƒ€ì… ì¶”ë¡ ì—ëŠ” ë¬¸ë§¥ì´ ê³ ë ¤ëœë‹¤

```tsx
// ìë°”ìŠ¤í¬ë¦½íŠ¸ëŠ” ì½”ë“œì˜ ë™ì‘ê³¼ ì‹¤í–‰ ìˆœì„œë¥¼ ë°”ê¾¸ì§€ ì•Šìœ¼ë©´ì„œ í‘œí˜„ì‹ì„ ìƒìˆ˜ë¡œ ë¶„ë¦¬í•´ë‚¼ ìˆ˜ ìˆë”°.
function setLanguage(language: string) {
  /* ... */
}

setLanguage('JavaScript') // OK

let language = 'JavaScript'
setLanguage(language) // OK

---

// ë¬¸ìì—´ íƒ€ì…ì„ íŠ¹ì •í•´ì„œ ë¬¸ìì—´ ë¦¬í„°ëŸ´ íƒ€ì…ì˜ ìœ ë‹ˆì˜¨ìœ¼ë¡œ ë°”ê¿”ë³´ì.
type Language = 'JavaScript' | 'TypeScript' | 'Python'
function setLanguage(language: Language) {
  /* ... */
}

setLanguage('JavaScript') // OK

let language = 'JavaScript'
setLanguage(language)
// ~~~~~~~~ Argument of type 'string' is not assignable
//          to parameter of type 'Language'

// 1. íƒ€ì… ì„ ì–¸ì—ì„œ languageì˜ ê°€ëŠ¥í•œ ê°’ì„ ì œí•œí•˜ê¸°
type Language = 'JavaScript' | 'TypeScript' | 'Python'
function setLanguage(language: Language) {
  /* ... */
}
let language: Language = 'JavaScript'
setLanguage(language) // OK

// 2. languageë¥¼ ìƒìˆ˜ë¡œ ë§Œë“¤ê¸°
type Language = 'JavaScript' | 'TypeScript' | 'Python'
function setLanguage(language: Language) {
  /* ... */
}
const language = 'JavaScript'
setLanguage(language) // OK
```

- ì´ ê³¼ì •ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë¬¸ë§¥ìœ¼ë¡œë¶€í„° ê°’ì„ ë¶„ë¦¬í–ˆë‹¤. ë¬¸ë§¥ê³¼ ê°’ì„ ë¶„ë¦¬í•˜ë©´ ì¶”í›„ì— ê·¼ë³¸ì ì¸ ë¬¸ì œë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆë‹¤.
- ì´ëŸ¬í•œ ë¬¸ë§¥ì˜ ì†Œì‹¤ë¡œ ì¸í•´ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ëª‡ ê°€ì§€ ê²½ìš°ì™€, ì´ë¥¼ ì–´ë–»ê²Œ í•´ê²°í•˜ëŠ”ì§€ ì‚´í´ë³´ì.

### íŠœí”Œ ì‚¬ìš© ì‹œ ì£¼ì˜ì 

```tsx
// Parameter is a (latitude, longitude) pair.
function panTo(where: [number, number]) {
  /* ... */
}

panTo([10, 20]); // OK

// ì´ë¯¸ constë¡œ ì„ ì–¸ë˜ì—ˆìŒì—ë„ number[]ë¡œ ì¶”ë¡ ëœë‹¤. (ê¸¸ì´ë¥¼ ì•Œ ìˆ˜ ì—†ìŒ)
const loc = [10, 20];
panTo(loc);
//    ~~~ Argument of type 'number[]' is not assignable to
//        parameter of type '[number, number]'

// 1. íƒ€ì… ì„ ì–¸ì„ ì œê³µí•œë‹¤.
const loc: [number, number] = [10, 20];
panTo(loc); // OK

// 2. 'ìƒìˆ˜ ë¬¸ë§¥'ì„ ì œê³µí•œë‹¤.
// as constëŠ” ê·¸ ê°’ì´ ë‚´ë¶€ê¹Œì§€(deeply) ìƒìˆ˜ë¼ëŠ” ì‚¬ì‹¤ì„ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ê²Œ ì•Œë ¤ì¤€ë‹¤.
const loc = [10, 20] as const;
// ê·¸ëŸ°ë° ì´ ì¶”ë¡ ì€ 'ë„ˆë¬´ ê³¼í™”ê²Œ' ì •í™•í•˜ë‹¤.
// loc ë§¤ê°œ ë³€ìˆ˜ê°€ readonly íƒ€ì…ì´ë¯€ë¡œ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤.
panTo(loc);
// ~~~ Type 'readonly [10, 20]' is 'readonly'
//     and cannot be assigned to the mutable type '[number, number]'

// panTo í•¨ìˆ˜ì— readonly êµ¬ë¬¸ì„ ì¶”ê°€í•´ì•¼ í•œë‹¤.
function panTo(where: readonly [number, number]) {
  /* ... */
}
const loc = [10, 20] as const;
panTo(loc); // OK
```

```tsx
// as constëŠ” ë¬¸ë§¥ ì†ì‹¤ê³¼ ê´€ë ¨í•œ ë¬¸ì œë¥¼ ê¹”ë”í•˜ê²Œ í•´ê²° í•  ìˆ˜ ìˆì§€ë§Œ, í•œ ê°€ì§€ ë‹¨ì ì„ ê°€ì§€ê³  ìˆë‹¤.
// ë§Œì•½ íƒ€ì… ì •ì˜ì— ì‹¤ìˆ˜ê°€ ìˆë‹¤ë©´ ì˜¤ë¥˜ëŠ” íƒ€ì… ì •ì˜ê°€ ì•„ë‹ˆë¼ í˜¸ì¶œë˜ëŠ” ê³³ì—ì„œ ë°œìƒí•œë‹¤.
// íŠ¹íˆ ì—¬ëŸ¬ ê²¹ ì¤‘ì²©ëœ ê°ì²´ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤ë©´ ê·¼ë³¸ì ì¸ ì›ì¸ì„ íŒŒì•…í•˜ê¸° ì–´ë µë‹¤.
function panTo(where: readonly [number, number]) {
  /* ... */
}
const loc = [10, 20, 30] as const; // error is really here.
panTo(loc);
//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to
//        parameter of type 'readonly [number, number]'
//          Types of property 'length' are incompatible
//            Type '3' is not assignable to type '2'
```

### ê°ì²´ ì‚¬ìš© ì‹œ ì£¼ì˜ì 

```tsx
type Language = 'JavaScript' | 'TypeScript' | 'Python';
interface GovernedLanguage {
  language: Language;
  organization: string;
}

function complain(language: GovernedLanguage) {
  /* ... */
}

complain({ language: 'TypeScript', organization: 'Microsoft' }); // OK

// ğŸ¤” ts ê°ì²´ì—ì„œ languageì˜ íƒ€ì…ì€ stringìœ¼ë¡œ ì¶”ë¡ ëœë‹¤.
const ts = {
  language: 'TypeScript',
  organization: 'Microsoft',
};
complain(ts);
//       ~~ Argument of type '{ language: string; organization: string; }'
//            is not assignable to parameter of type 'GovernedLanguage'
//          Types of property 'language' are incompatible
//            Type 'string' is not assignable to type 'Language'

// âœ… 1. íƒ€ì… ì„ ì–¸ì„ ì¶”ê°€í•˜ê±°ë‚˜
const ts: GovernedLanguage = {
  language: 'TypeScript',
  organization: 'Microsoft',
};

// âœ… 2. ìƒìˆ˜ ë‹¨ì–¸ì„ ì‚¬ìš©í•´ í•´ê²°í•œë‹¤.
const ts = {
  language: 'TypeScript',
  organization: 'Microsoft',
} as const;
```

### ì½œë°± ì‚¬ìš© ì‹œ ì£¼ì˜ì 

```tsx
function callWithRandomNumbers(fn: (n1: number, n2: number) => void) {
  fn(Math.random(), Math.random());
}

// callWithRandomNumbersì˜ íƒ€ì… ì„ ì–¸ìœ¼ë¡œ ì¸í•´ aì™€ bì˜ íƒ€ì…ì´ numberë¡œ ì¶”ë¡ ëœë‹¤.
callWithRandomNumbers((a, b) => {
  a; // Type is number
  b; // Type is number
  console.log(a + b);
});

// ì½œë°±ì„ ìƒìˆ˜ë¡œ ë½‘ì•„ë‚´ë©´ ë¬¸ë§¥ì˜ ì†Œì‹¤ë˜ê³  noImplicitAny ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
const fn = (a, b) => {
  // ~    Parameter 'a' implicitly has an 'any' type
  //    ~ Parameter 'b' implicitly has an 'any' type
  console.log(a + b);
};
callWithRandomNumbers(fn);

// ë§¤ê°œë³€ìˆ˜ì— íƒ€ì… êµ¬ë¬¸ì„ ì¶”ê°€í•´ì„œ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
const fn = (a: number, b: number) => {
  console.log(a + b);
};
```

### ìš”ì•½

- íƒ€ì… ì¶”ë¡ ì—ì„œ ë¬¸ë§¥ì´ ì–´ë–»ê²Œ ì“°ì´ëŠ”ì§€ ì£¼ì˜í•´ì„œ ì‚´í´ë´ì•¼ í•œë‹¤.
- ë³€ìˆ˜ë¥¼ ë½‘ì•„ì„œ ë³„ë„ë¡œ ì„ ì–¸í–ˆì„ ë•Œ ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤ë©´ íƒ€ì… ì„ ì–¸ì„ ì¶”ê°€í•´ì•¼ í•œë‹¤.
- ë³€ìˆ˜ê°€ ì •ë§ë¡œ ìƒìˆ˜ë¼ë©´ ìƒìˆ˜ ë‹¨ì–¸(as const)ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤. ê·¸ëŸ¬ë‚˜ ìƒìˆ˜ ë‹¨ì–¸ì„ ì‚¬ìš©í•˜ë©´ ì •ì˜í•œ ê³³ì´ ì•„ë‹ˆë¼ ì‚¬ìš©í•œ ê³³ì—ì„œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ë¯€ë¡œ ì£¼ì˜í•´ì•¼ í•œë‹¤.

## ì•„ì´í…œ 27 í•¨ìˆ˜í˜• ê¸°ë²•ê³¼ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¡œ íƒ€ì… íë¦„ ìœ ì§€í•˜ê¸°

```tsx
const csvData = '...';
const rawRows = csvData.split('\n');
const headers = rawRows[0].split(',');

const rows = rawRows.slice(1).map((rowStr) => {
  const row = {};
  rowStr.split(',').forEach((val, j) => {
    row[headers[j]] = val;
  });
  return row;
});

// í•¨ìˆ˜í˜•ìœ¼ë¡œ ë³€ê²½í•´ë³´ì.
const rows = rawRows
  .slice(1)
  .map((rowStr) => rowStr.split(',').reduce((row, val, i) => ((row[headers[i]] = val), row), {}));

// ë¡œëŒ€ì‹œì˜ zipObject í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ë©´ ì½”ë“œë¥¼ ë”ìš± ì§§ê²Œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
import _ from 'lodash';

const rows = rawRows.slice(1).map((rowStr) => _.zipObject(headers, rowStr.split(',')));
```

```tsx
// ì ˆì°¨í˜• ë²„ì „ê³¼ í•¨ìˆ˜í˜• ë²„ì „ ëª¨ë‘ ê°™ì€ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œí‚¨ë‹¤.
const rowsA = rawRows.slice(1).map((rowStr) => {
  const row = {};
  rowStr.split(',').forEach((val, j) => {
    row[headers[j]] = val;
    // ~~~~~~~~~~~~~~~ No index signature with a parameter of
    //                 type 'string' was found on type '{}'
  });
  return row;
});

const rowsB = rawRows.slice(1).map((rowStr) =>
  rowStr.split(',').reduce(
    (row, val, i) => ((row[headers[i]] = val), row),
    // ~~~~~~~~~~~~~~~ No index signature with a parameter of
    //                 type 'string' was found on type '{}'
    {}
  )
);

// ë°˜ë©´ ë¡œëŒ€ì‹œ ë²„ì „ì€ ë³„ë„ì˜ ìˆ˜ì • ì—†ì´ë„ íƒ€ì… ì²´ì»¤ë¥¼ í†µê³¼í•œë‹¤.
import _ from 'lodash';

const rows = rawRows.slice(1).map((rowStr) => _.zipObject(headers, rowStr.split(',')));
// Type is _.Dictionary<string>[]
```

```tsx
import _ from 'lodash';

interface BasketballPlayer {
  name: string;
  team: string;
  salary: number;
}

declare const rosters: { [team: string]: BasketballPlayer[] };

// ë‹¤ìŒ ì½”ë“œëŠ” ë™ì‘ì´ ë˜ì§€ë§Œ íƒ€ì… ì²´í¬ëŠ” ë˜ì§€ ì•ŠëŠ”ë‹¤.
let allPlayers = [];
// ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'
//            in some locations where its type cannot be determined
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players);
  // ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type
}

// ì´ ì˜¤ë¥˜ë¥¼ ê³ ì¹˜ë ¤ë©´ allPlayersdp íƒ€ì… êµ¬ë¬¸ì„ ì¶”ê°€í•´ì•¼ í•œë‹¤.
let allPlayers: BasketballPlayer[] = [];
for (const players of Object.values(rosters)) {
  allPlayers = allPlayers.concat(players); // OK
}

// ê·¸ëŸ¬ë‚˜ ë” ë‚˜ì€ í•´ë²•ì€ Array.prototype.flatì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.
const allPlayers = Object.values(rosters).flat();
// OK, type is BasketballPlayer[]
```

```tsx
// allPlayersë¥¼ ê°€ì§€ê³  ê° íŒ€ë³„ë¡œ ì—°ë´‰ ìˆœìœ¼ë¡œ ì •ë ¬í•´ì„œ ìµœê³  ì—°ë´‰ ì„ ìˆ˜ì˜ ëª…ë‹¨ì„ ë§Œë“ ë‹¤ê³  ê°€ì •í•´ë³´ì.
const teamToPlayers: { [team: string]: BasketballPlayer[] } = {};
for (const player of allPlayers) {
  const { team } = player;
  teamToPlayers[team] = teamToPlayers[team] || [];
  teamToPlayers[team].push(player);
}

for (const players of Object.values(teamToPlayers)) {
  players.sort((a, b) => b.salary - a.salary);
}

const bestPaid = Object.values(teamToPlayers).map((players) => players[0]);
bestPaid.sort((playerA, playerB) => playerB.salary - playerA.salary);
console.log(bestPaid);

// ë¡œëŒ€ì‹œë¥¼ ì‚¬ìš©í•´ì„œ ë™ì¼í•œ ì‘ì—…ì„ í•˜ëŠ” ì½”ë“œë¥¼ êµ¬í˜„í•˜ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤.
// ë¡œëŒ€ì‹œì™€ ì–¸ë”ìŠ¤ì½”ì–´ì˜ ê°œë…ì•ˆ 'ì²´ì¸'ì„ ì‚¬ìš©í–ˆê¸° ë•Œë¬¸ì—, ë” ìì—°ìŠ¤ëŸ¬ìš´ ìˆœì„œë¡œ ì¼ë ¨ì˜ ìˆœì„œë¥¼ ì‘ì„±í•  ìˆ˜ ìˆë‹¤.
// ì²´ì¸ì„ ì‚¬ìš©í•˜ë©´ ì—°ì‚°ìì˜ ë“±ì¥ ìˆœì„œì™€ ì‹¤í–‰ ìˆœì„œê°€ ë™ì¼í•˜ê²Œ ëœë‹¤.
const bestPaid = _(allPlayers)
  .groupBy((player) => player.team)
  .mapValues((players) => _.maxBy(players, (p) => p.salary)!)
  .values()
  .sortBy((p) => -p.salary)
  .value(); // Type is BasketballPlayer[]
```

```tsx
// ë‚´ì¥ëœ Array.prototype.map ëŒ€ì‹  ._mapì„ ì‚¬ìš©í•˜ë ¤ëŠ” ì´ìœ ëŠ” ë¬´ì—‡ì¼ê¹Œ?
// í•œ ê°€ì§€ ì´ìœ ëŠ” ì½œë°±ì„ ì „ë‹¬í•˜ëŠ” ëŒ€ì‹  ì†ì„±ì˜ ì´ë¦„ì„ ì „ë‹¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.
const namesA = allPlayers.map((player) => player.name); // Type is string[]
const namesB = _.map(allPlayers, (player) => player.name); // Type is string[]
const namesC = _.map(allPlayers, 'name'); // Type is string[]

const salaries = _.map(allPlayers, 'salary'); // Type is number[]
const teams = _.map(allPlayers, 'team'); // Type is string[]
const mix = _.map(allPlayers, Math.random() < 0.5 ? 'name' : 'salary');
// Type is (string | number)[]
```

### ìš”ì•½

- íƒ€ì… íë¦„ì„ ê°œì„ í•˜ê³ , ê°€ë…ì„±ì„ ë†’ì´ê³ , ëª…ì‹œì ì¸ íƒ€ì… êµ¬ë¬¸ì˜ í•„ìš”ì„±ì„ ì¤„ì´ê¸° ìœ„í•´ ì§ì ‘ êµ¬í˜„í•˜ê¸°ë³´ë‹¤ëŠ” ë‚´ì¥ëŒ€ í•¨ìˆ˜í˜• ê¸°ë²•ê³¼ ë¡œëŒ€ì‹œ ê°™ì€ ìœ í‹¸ë¦¬í‹° ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
