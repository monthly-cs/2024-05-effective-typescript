# DIL: ì´í™í‹°ë¸Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸

> ìŠ¤í„°ë””: ì›”ê°„ CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> ì‘ì„±ì¼: 2024-05-16
> ì‘ì„±ì: w00khyung

---

# ì•„ì´í…œ 14 íƒ€ì… ì—°ì‚°ê³¼ ì œë„ˆë¦­ ì‚¬ìš©ìœ¼ë¡œ ë°˜ë³µ ì¤„ì´ê¸°

```tsx
// ğŸ¤” ë¹„ìŠ·í•œ ì½”ë“œê°€ ë°˜ë³µë˜ê³  ìˆì–´ ë³´ê¸° ë¶ˆí¸í•˜ë‹¤.
console.log('Cylinder 1 x 1 ', 'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 1 * 1, 'Volume:', 3.14159 * 1 * 1 * 1);
console.log('Cylinder 1 x 2 ', 'Surface area:', 6.283185 * 1 * 1 + 6.283185 * 2 * 1, 'Volume:', 3.14159 * 1 * 2 * 1);
console.log('Cylinder 2 x 1 ', 'Surface area:', 6.283185 * 2 * 1 + 6.283185 * 2 * 1, 'Volume:', 3.14159 * 2 * 2 * 1);

// âœ… ìœ„ ì½”ë“œì—ì„œ í•¨ìˆ˜, ìƒìˆ˜, ë£¨í”„ì˜ ë°˜ë³µì„ ì œê±°í•´ ì½”ë“œë¥¼ ê°œì„ í–ˆë‹¤. (DRY)
const surfaceArea = (r: number, h: number) => 2 * Math.PI * r * (r + h);
const volume = (r: number, h: number) => Math.PI * r * r * h;
for (const [r, h] of [
  [1, 1],
  [1, 2],
  [2, 1],
]) {
  console.log(`Cylinder ${r} x ${h}, Surface area: ${surfaceArea(r, h)}, Volume: ${volume(r, h)}`);
}
```

### íƒ€ì… ì¤‘ë³µ

```tsx
interface Person {
  **firstName: string**
  **lastName: string**
}

interface PersonWithBirthDate {
  **firstName: string**
  **lastName: string**
  birth: Date
}

// ğŸ¤” Personì— middleNameì´ë¼ëŠ” ì„ íƒì  í•„ë“œë¥¼ ì¶”ê°€í•œë‹¤ë©´?
// Personê³¼ PersonWithBirthDateëŠ” ë‹¤ë¥¸ íƒ€ì…ì´ ëœë‹¤.
interface Person {
  **firstName: string**
  **lastName: string**
  middleName?: string;
}
```

- íƒ€ì… ì¤‘ë³µì€ ì½”ë“œ ì¤‘ë³µë§Œí¼ ë§ì€ ë¬¸ì œë¥¼ ë°œìƒì‹œí‚¨ë‹¤.

### ë°˜ë³µì„ ì¤„ì´ëŠ” ê°€ì¥ ê°„ë‹¨í•œ ë°©ë²•, íƒ€ì…ì— ì´ë¦„ ë¶™ì´ê¸°

```tsx
function distance(a: { x: number; y: number }, b: { x: number; y: number }) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

interface Point2D {
  x: number;
  y: number;
}

// âœ… interfaceì„ ì„ ì–¸í•¨ìœ¼ë¡œì¨ ì¤‘ë³µì„ ì—†ì•´ë‹¤.
function distance(a: Point2D, b: Point2D) {
  /* ... */
}
```

```tsx
interface Options {}

function get(url: string, opts: Options): Promise<Response> {
  /* COMPRESS */ return Promise.resolve(new Response()); /* END */
}
function post(url: string, opts: Options): Promise<Response> {
  /* COMPRESS */ return Promise.resolve(new Response()); /* END */
}

interface Options {}

// âœ… ì‹œê·¸ë‹ˆì²˜ë¥¼ ëª…ëª…ëœ íƒ€ì…ìœ¼ë¡œ ë¶„ë¦¬í•´ ë‚¼ ìˆ˜ ìˆë‹¤.
type HTTPFunction = (url: string, options: Options) => Promise<Response>;

const get: HTTPFunction = (url, options) => {
  /* COMPRESS */ return Promise.resolve(new Response()); /* END */
};
const post: HTTPFunction = (url, options) => {
  /* COMPRESS */ return Promise.resolve(new Response()); /* END */
};
```

```tsx
interface Person {
  firstName: string;
  lastName: string;
}

// âœ… ì¸í„°í˜ì´ìŠ¤ë¥¼ í™•ì¥í•¨ìœ¼ë¡œì¨ ë°˜ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.
interface PersonWithBirthDate extends Person {
  birth: Date;
}

// í˜¹ì€ ì¸í„°ì„¹ì…˜ ì—°ì‚°ì(&)ë¥¼ ì‚¬ìš©í•œë‹¤.
type PersonWithBirthDate = Person & { birth: Date };
```

```tsx
interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}

// âœ… TopNavStateë¥¼ í™•ì¥í•˜ì—¬ Stateë¥¼ êµ¬ì„±í•˜ê¸°ë³´ë‹¤, Stateì˜ ë¶€ë¶„ ì§‘í•©ìœ¼ë¡œ TopNavStateë¥¼ ì •ì˜í•˜ëŠ” ê²ƒì´ ë°”ëŒì§í•˜ë‹¤.
interface TopNavState {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
}

// âœ… Stateë¥¼ ì¸ë±ì‹±í•˜ì—¬ ì†ì„±ì˜ íƒ€ì…ì—ì„œ ì¤‘ë³µì„ ì œê±°í–ˆë‹¤.
type TopNavState = {
  userId: State['userId'];
  pageTitle: State['pageTitle'];
  recentFiles: State['recentFiles'];
};

// âœ… 'ë§¤í•‘ëœ íƒ€ì…'ì„ ì‚¬ìš©í•˜ë©´ ì¢€ ë” ë‚˜ì•„ì§‘ë‹ˆë‹¤.
type TopNavState = {
  [k in 'userId' | 'pageTitle' | 'recentFiles']: State[k];
};

// https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys
type TopNavState = Pick<State, 'userId' | 'pageTitle' | 'recentFiles'>;
```

### Pick

- https://www.typescriptlang.org/docs/handbook/utility-types.html#picktype-keys
- Pickì€ ì œë„ˆë¦­ íƒ€ì…ì´ë‹¤. ì¤‘ë³µëœ ì½”ë“œë¥¼ ì—†ì•¤ë‹¤ëŠ” ê´€ì ìœ¼ë¡œ, Pickì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì— ë¹„ìœ í•  ìˆ˜ ìˆë‹¤.
- Pickì€ Tì™€ K ë‘ê°€ì§€ íƒ€ì…ì„ ë°›ì•„ì„œ ê²°ê³¼ íƒ€ì…ì„ ë°˜í™˜í•œë‹¤.

```tsx
/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};
```

```tsx
interface SaveAction {
  type: 'save';
  // ...
}
interface LoadAction {
  type: 'load';
  // ...
}
type Action = SaveAction | LoadAction;
type ActionType = 'save' | 'load'; // íƒ€ì…ì˜ ë°˜ë³µ!

// âœ… Action ìœ ë‹ˆì˜¨ì„ ì¸ë±ì‹±í•˜ë©´ íƒ€ì… ë°˜ë³µ ì—†ì´ ActionTypeì„ ì •ì˜í•  ìˆ˜ ìˆë‹¤.
type ActionType = Action['type']; // Type is "save" | "load"

// âœ… ActionTypeì€ Pickì„ ì‚¬ìš©í•˜ì—¬ ì–»ê²Œ ë˜ëŠ”, type ì†ì„±ì„ ê°€ì§€ëŠ” ì¸í„°í˜ì´ìŠ¤ì™€ëŠ” ë‹¤ë¥´ë‹¤.
type ActionRec = Pick<Action, 'type'>; // {type: "save" | "load"}
```

### Partial

```tsx
interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

// ğŸ¤” í•œë²ˆ ìƒì„±í•˜ê³  ë‚œ ë‹¤ìŒ ì—…ë°ì´íŠ¸ ë˜ëŠ” í´ë˜ìŠ¤ì˜ update ë©”ì„œë“œ ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì€
// ìƒì„±ìì™€ ë™ì¼í•œ ë§¤ê°œë³€ìˆ˜ì´ë©´ì„œ, íƒ€ì… ëŒ€ë¶€ë¶„ì´ ì„ íƒì  í•„ë“œê°€ ëœë‹¤.
interface OptionsUpdate {
  width?: number;
  height?: number;
  color?: string;
  label?: string;
}

class UIWidget {
  constructor(init: Options) {
    /* ... */
  }
  update(options: OptionsUpdate) {
    /* ... */
  }
}

interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

// âœ… ë§¤í•‘ëœ íƒ€ì…ê³¼ keyofë¥¼ ì‚¬ìš©í•˜ë©´ Optionsìœ¼ë¡œë¶€í„° OptionsUpdateë¥¼ ë§Œë“¤ ìˆ˜ ìˆë‹¤.
// keyofëŠ” íƒ€ì…ì„ ë°›ì•„ì„œ ì†ì„± íƒ€ì…ì˜ ìœ ë‹ˆì˜¨ì„ ë°˜í™˜í•œë‹¤.
type OptionsUpdate = { [k in keyof Options]?: Options[k] };

type OptionsKeys = keyof Options;
// Type is "width" | "height" | "color" | "label"
```

```tsx
/**
 * Make all properties in T optional
 */
type Partial<T> = {
  [P in keyof T]?: T[P];
};

interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

class UIWidget {
  constructor(init: Options) {
    /* ... */
  }
  update(options: Partial<Options>) {
    /* ... */
  }
}
```

### typeof

```tsx
// ğŸ¤” ê°’ì˜ í˜•íƒœì— í•´ë‹¹í•˜ëŠ” íƒ€ì…ì„ ì •ì˜í•˜ê³  ì‹¶ë‹¤.
const INIT_OPTIONS = {
  width: 640,
  height: 480,
  color: '#00FF00',
  label: 'VGA',
};

interface Options {
  width: number;
  height: number;
  color: string;
  label: string;
}

// âœ… typeofë¥¼ ì‚¬ìš©í•œë‹¤.
type Options = typeof INIT_OPTIONS;
```

### ReturnType

```tsx
// ğŸ¤” í•¨ìˆ˜ë‚˜ ë©”ì„œë“œì˜ ë°˜í™˜ ê°’ì— ëª…ëª…ëœ íƒ€ì…ì„ ë§Œë“¤ê³  ì‹¶ë‹¤.
function getUserInfo(userId: string) {
  // COMPRESS
  const name = 'Bob';
  const age = 12;
  const height = 48;
  const weight = 70;
  const favoriteColor = 'blue';
  // END
  return {
    userId,
    name,
    age,
    height,
    weight,
    favoriteColor,
  };
}
// Return type inferred as { userId: string; name: string; age: number, ... }
```

```tsx
/**
 * Obtain the return type of a function type
 */
type ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;

type UserInfo = ReturnType<typeof getUserInfo>;

// ReturnTypeì€ í•¨ìˆ˜ì˜ 'ê°’'ì¸ getUserInfoê°€ ì•„ë‹ˆë¼ í•¨ìˆ˜ì˜ 'íƒ€ì…'ì¸
// typeof getUserInfoì— ì ìš©ë˜ì—ˆë‹¤.
```

### extends

- í•¨ìˆ˜ì—ì„œ ë§¤ê°œë³€ìˆ˜ë¡œ ë§¤í•‘í•  ìˆ˜ ìˆëŠ” ê°’ì„ ì œí•œí•˜ê¸° ìœ„í•´ íƒ€ì… ì‹œìŠ¤í…œì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì²˜ëŸ¼ ì œë„ˆë¦­ íƒ€ì…ì—ì„œ ë§¤ê°œë³€ìˆ˜ë¥¼ ì œí•œí•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€ extendsë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.

```tsx
interface Name {
  first: string;
  last: string;
}

type DancingDuo<T extends Name> = [T, T];

const couple1: DancingDuo<Name> = [
  { first: 'Fred', last: 'Astaire' },
  { first: 'Ginger', last: 'Rogers' },
]; // OK

// âŒ { first: string } ì€ Nameì„ í™•ì¥í•˜ê¸° ì•Šê¸° ë•Œë¬¸ì— ì˜¤ë¥˜ê°€ ë°œìƒí•œë‹¤.
const couple2: DancingDuo<{ first: string }> = [
  // ~~~~~~~~~~~~~~~
  // Property 'last' is missing in type
  // '{ first: string; }' but required in type 'Name'
  { first: 'Sonny' },
  { first: 'Cher' },
];
```

## ìš”ì•½

- DRY(Donâ€™t Repeat Yourself) ì›ì¹™ì„ íƒ€ì…ì—ë„ ìµœëŒ€í•œ ì ìš©í•˜ì.
- íƒ€ì…ì— ì´ë¦„ì„ ë¶™ì—¬ì„œ ë°˜ë³µì„ í”¼í•´ì•¼ í•œë‹¤. `extends` ë¥¼ ì‚¬ìš©í•´ì„œ ì¸í„°í˜ì´ìŠ¤ í•„ë“œì˜ ë°˜ë³µì„ í”¼í•´ì•¼ í•œë‹¤.
- íƒ€ì…ë“¤ ê°„ì˜ ë§¤í•‘ì„ ìœ„í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì œê³µí•œ ë„êµ¬ë“¤ì„ ê³µë¶€í•˜ë©´ ì¢‹ë‹¤. ì—¬ê¸°ì—ëŠ” keyof, typeof, ì¸ë±ì‹±, ë§¤í•‘ëœ íƒ€ì…ë“¤ì´ í¬í•¨ëœë‹¤.
- ì œë„ˆë¦­ íƒ€ì…ì€ íƒ€ì…ì„ ìœ„í•œ í•¨ìˆ˜ì™€ ê°™ë‹¤. íƒ€ì…ì„ ë°˜ë³µí•˜ëŠ” ëŒ€ì‹  ì œë„ˆë¦­ íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ íƒ€ì…ë“¤ ê°„ì— ë§¤í•‘ì„ í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤. ì œë„ˆë¦­ íƒ€ì…ì„ ì œí•œí•˜ë ¤ë©´ extendsë¥¼ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
- í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì •ì˜ë¤ Pick, Partial, ReturnType ê°™ì€ ì œë„ˆë¦­ íƒ€ì…ì— ìµìˆ™í•´ì ¸ì•¼ í•œë‹¤.

# ì•„ì´í…œ 15 ë™ì  ë°ì´í„°ì— ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ ì‚¬ìš©í•˜ê¸°

### ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜

```tsx
// íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” íƒ€ì…ì— 'ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜'ë¥¼ ëª…ì‹œí•˜ì—¬ ìœ ì—°í•˜ê²Œ ë§¤í•‘ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
type Rocket = { [property: string]: string };

const rocket: Rocket = {
  name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
};
```

- [property: string]: stringì´ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì´ë©°, ë‹¤ìŒ ì„¸ ê°€ì§€ ì˜ë¯¸ë¥¼ ë‹´ê³  ìˆë‹¤.
  - í‚¤ì˜ ì´ë¦„: í‚¤ì˜ ìœ„ì¹˜ë§Œ í‘œì‹œí•˜ëŠ” ìš©ë„ì´ë‹¤. íƒ€ì… ì²´ì»¤ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë¬´ì‹œí•  ìˆ˜ ìˆëŠ” ì°¸ê³  ì •ë³´ë¼ê³  ìƒê°í•´ë„ ëœë‹¤.
  - í‚¤ì˜ íƒ€ì…: stringì´ë‚˜ number ë˜ëŠ” symbolì˜ ì¡°í•©ì´ì–´ì•¼ í•˜ì§€ë§Œ, ë³´í†µì€ stringì„ ì‚¬ìš©í•œë‹¤.
  - ê°’ì˜ íƒ€ì…: ì–´ë–¤ ê²ƒì´ë“  ë  ìˆ˜ ìˆë‹¤.
- ì´ë ‡ê²Œ íƒ€ì… ì²´í¬ê°€ ìˆ˜í–‰ë˜ë©´ ë„¤ ê°€ì§€ ë‹¨ì ì´ ë“œëŸ¬ë‚œë‹¤.

```tsx
type Rocket = { [property: string]: string }

const rocket: Rocket = {
	// 1. ì˜ëª»ëœ í‚¤ë¥¼ í¬í•¨í•´ ëª¨ë“  í‚¤ë¥¼ í—ˆìš©í•œë‹¤.
  Name: 'Falcon 9',
  variant: 'v1.0',
  thrust: '4,940 kN',
}

// 2. íŠ¹ì • í‚¤ê°€ í•„ìš”í•˜ì§€ ì•Šë‹¤.
const rocket: Rocket = {}

const rocket: Rocket = {
  Name: 'Falcon 9',
  variant: 'v1.0',
  // 3. í‚¤ë§ˆë‹¤ ë‹¤ë¥¸ íƒ€ì…ì„ ê°€ì§ˆ ìˆ˜ ì—†ë‹¤.
  thrust: 100,
}

const rocket: Rocket = {
  // 4. í‚¤ëŠ” ë¬´ì—‡ì´ë“  ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ìë™ì™„ì„± ê¸°ëŠ¥ì´ ë™ì‘í•˜ì§€ ì•ŠëŠ”ë‹¤.
  name: ?
}

// âœ… ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ëŠ” ë¶€ì •í™•í•˜ë¯€ë¡œ ë” ë‚˜ì€ ë°©ë²•ì„ ì°¾ì•„ì•¼ í•œë‹¤.
```

```tsx
// âœ… thrust_kNì€ number íƒ€ì…ì´ë©°, íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ëŠ” ëª¨ë“  í•„ìˆ˜ í•„ë“œê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸í•œë‹¤.
interface Rocket {
  name: string;
  variant: string;
  thrust_kN: number;
}

const falconHeavy: Rocket = {
  name: 'Falcon Heavy',
  variant: 'v1',
  thrust_kN: 15_200,
};
```

```tsx
// ğŸ¤” ì¼ë°˜ì ì¸ ìƒí™©ì—ì„œ ì—´ ì´ë¦„ì´ ë¬´ì—‡ì¸ì§€ ë¯¸ë¦¬ ì•Œ ë°©ë²•ì€ ì—†ë‹¤.
function parseCSV(input: string): { [columnName: string]: string }[] {
  const lines = input.split('\n');
  const [header, ...rows] = lines;
  return rows.map((rowStr) => {
    const row: { [columnName: string]: string } = {};
    rowStr.split(',').forEach((cell, i) => {
      row[header[i]] = cell;
    });
    return row;
  });
}

// âœ… ì—´ ì´ë¦„ì„ ì•Œê³  ìˆëŠ” íŠ¹ì •í•œ ìƒí™©ì´ë¼ë©´, ë¯¸ë¦¬ ì„ ì–¸í•´ ë‘” íƒ€ì…ìœ¼ë¡œ ë‹¨ì–¸ë¬¸ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
interface ProductRow {
  productId: string;
  name: string;
  price: string;
}

declare let csvData: string;
const products = parseCSV(csvData) as unknown as ProductRow[];

// âœ… ì„ ì–¸í•´ ë‘” ì—´ë“¤ì´ ëŸ°íƒ€ì„ì— ì‹¤ì œë¡œ ì¼ì¹˜í•œë‹¤ëŠ” ë³´ì¥ì´ ì—†ë‹¤.
// ì´ ë¶€ë¶„ì´ ê±±ì •ëœë‹¤ë©´ ê°’ íƒ€ì…ì— undefinedë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.
function safeParseCSV(input: string): { [columnName: string]: string | undefined }[] {
  return parseCSV(input);
}

const rows = parseCSV(csvData);
const prices: { [produt: string]: number } = {};
for (const row of rows) {
  prices[row.productId] = Number(row.price);
}

const safeRows = safeParseCSV(csvData);
for (const row of safeRows) {
  // âœ… ì´ì œ ëª¨ë“  ì—´ì˜ undefined ì—¬ë¶€ë¥¼ ì²´í¬í•´ì•¼ í•œë‹¤.
  prices[row.productId] = Number(row.price);
  // ~~~~~~~~~~~~~ Type 'undefined' cannot be used as an index type
}
```

### íƒ€ì…ì— ê°€ëŠ¥í•œ í•„ë“œê°€ ì œí•œë˜ì–´ ìˆëŠ” ê²½ìš°

```tsx
interface Row1 {
  [column: string]: number;
} // ë„ˆë¬´ ê´‘ë²”ìœ„

interface Row2 {
  a: number;
  b?: number;
  c?: number;
  d?: number;
} // ìµœì„ 

type Row3 =
  | { a: number }
  | { a: number; b: number }
  | { a: number; b: number; c: number }
  | { a: number; b: number; c: number; d: number }; // ê°€ì¥ ì •í™•í•˜ì§€ë§Œ ì‚¬ìš©í•˜ê¸° ë²ˆê±°ë¡œì›€
```

```tsx
// 1. Record
// í‚¤ íƒ€ì…ì— ìœ ì—°ì„±ì„ ì œê³µí•˜ëŠ” ì œë„ˆë¦­ íƒ€ì…ì´ë‹¤.
type Vec3D = Record<'x' | 'y' | 'z', number>;
// Type Vec3D = {
//   x: number;
//   y: number;
//   z: number;
// }

// 2. ë§¤í•‘ëœ íƒ€ì… ì‚¬ìš©
// í‚¤ë§ˆë‹¤ ë³„ë„ì˜ íƒ€ì…ì„ ì‚¬ìš©í•˜ê²Œ í•´ì¤€ë‹¤.
type Vec3D = { [k in 'x' | 'y' | 'z']: number };
// Same as above
type ABC = { [k in 'a' | 'b' | 'c']: k extends 'b' ? string : number };
// Type ABC = {
//   a: number;
//   b: string;
//   c: number;
// }
```

## ìš”ì•½

- ëŸ°íƒ€ì„ ë•Œê¹Œì§€ ê°ì²´ì˜ ì†ì„±ì„ ì•Œ ìˆ˜ ì—†ëŠ” ê²½ìš°ì—ë§Œ(ì˜ˆë¥¼ ë“¤ì–´ CSV íŒŒì¼ì—ì„œ ë¡œë“œí•˜ëŠ” ê²½ìš°) ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ë¥¼ ì‚¬ìš©í•˜ë„ë¡ í•˜ì.
- ì•ˆì „í•œ ì ‘ê·¼ì„ ìœ„í•´ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì˜ ê°’ íƒ€ì…ì— undefinedë¥¼ ì¶”ê°€í•˜ëŠ” ê²ƒì„ ê³ ë ¤í•´ì•¼ í•œë‹¤.
- ê°€ëŠ¥í•˜ë‹¤ë©´ ì¸í„°í˜ì´ìŠ¤, Record, ë§¤í•‘ëœ íƒ€ì… ê°™ì€ ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ë³´ë‹¤ ì •í™•í•œ íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

# ì•„ì´í…œ 16 number ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ë³´ë‹¤ëŠ” Array, íŠœí”Œ, ArrayLikeë¥¼ ì‚¬ìš©í•˜ê¸°

```tsx
const xs = [1, 2, 3];
const x0 = xs[0]; // OK
const x1 = xs['1'];
// ~~~ Element implicitly has an 'any' type
//      because index expression is not of type 'number'

function get<T>(array: T[], k: string): T {
  return array[k];
  // ~ Element implicitly has an 'any' type
  //   because index expression is not of type 'number'
}
```

```tsx
const xs = [1, 2, 3];
const keys = Object.keys(xs); // Type is string[]
for (const key in xs) {
  key; // Type is string
  // ğŸ¤” stringì´ numberì— í• ë‹¹ë  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—, ë™ì‘í•˜ëŠ” ê²ƒì´ ì´ìƒí•˜ê²Œ ë³´ì¸ë‹¤.
  // ë°°ì—´ì„ ìˆœíšŒí•˜ëŠ” ì½”ë“œ ìŠ¤íƒ€ì¼ì— ëŒ€í•œ ì‹¤ìš©ì ì¸ í—ˆìš©ì´ë‹¤.
  const x = xs[key]; // Type is number
}
```

```tsx
// âœ… ì¸ë±ìŠ¤ì— ì‹ ê²½ ì“°ì§€ ì•ŠëŠ”ë‹¤ë©´, for~ofë¥¼ ì‚¬ìš©í•˜ëŠ” ê²Œ ë” ì¢‹ë‹¤.
const xs = [1, 2, 3];
for (const x of xs) {
  x; // Type is number
}
```

```tsx
// âœ… ì¸ë±ìŠ¤ì˜ íƒ€ì…ì´ ì¤‘ìš”í•˜ë‹¤ë©´ number íƒ€ì…ì„ ì œê³µí•´ ì¤„ Array.prototype.forEachë¥¼ ì‚¬ìš©í•˜ë©´ ëœë‹¤.
const xs = [1, 2, 3];
xs.forEach((x, i) => {
  i; // Type is number
  x; // Type is number
});
```

```tsx
// âœ… ë£¨í”„ ì¤‘ê°„ì— ë©ˆì¶°ì•¼ í•œë‹¤ë©´, C ìŠ¤íƒ€ì¼ì¸ for(;;) ë£¨í”„ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
const xs = [1, 2, 3];
for (let i = 0; i < xs.length; i++) {
  const x = xs[i];
  if (x < 0) break;
}
```

```tsx
// âœ… ì–´ë–¤ ê¸¸ì´ë¥¼ ê°€ì§€ëŠ” ë°°ì—´ê³¼ ë¹„ìŠ·í•œ í˜•íƒœì˜ íŠœí”Œì„ ì‚¬ìš©í•˜ê³  ì‹¶ë‹¤ë©´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì— ìˆëŠ” ArrayLike íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤.
const xs = [1, 2, 3];
function checkedAccess<T>(xs: ArrayLike<T>, i: number): T {
  if (i < xs.length) {
    return xs[i];
  }
  throw new Error(`Attempt to access ${i} which is past end of array.`);
}

const xs = [1, 2, 3];
const tupleLike: ArrayLike<string> = {
  '0': 'A',
  '1': 'B',
  length: 2,
};
```

# ìš”ì•½

- ë°°ì—´ì€ ê°ì²´ì´ë¯€ë¡œ í‚¤ëŠ” ìˆ«ìê°€ ì•„ë‹ˆë¼ ë¬¸ìì—´ì´ë‹¤. ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ë¡œ ì‚¬ìš©ëœ number íƒ€ì…ì€ ë²„ê·¸ë¥¼ ì¡ê¸° ìœ„í•œ ìˆœìˆ˜ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ ì½”ë“œì´ë‹¤.
- ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì— numberë¥¼ ì‚¬ìš©í•˜ê¸°ë³´ë‹¤ Arrayë‚˜ íŠœí”Œ, ë˜ëŠ” ArrayLike íƒ€ì…ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

# ì•„ì´í…œ 17 ë³€ê²½ ê´€ë ¨ëœ ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•´ readonly ì‚¬ìš©í•˜ê¸°

```tsx
function arraySum(arr: number[]) {
  let sum = 0,
    num;
  // ğŸ¤” ê³„ì‚°ì´ ëë‚˜ë©´ ì›ë˜ ë°°ì—´ì´ ì „ë¶€ ë¹„ê²Œ ëœë‹¤.
  while ((num = arr.pop()) !== undefined) {
    sum += num;
  }
  return sum;
}

function printTriangles(n: number) {
  const nums = [];
  for (let i = 0; i < n; i++) {
    nums.push(i);
    console.log(arraySum(nums));
  }
}
```

```tsx
function arraySum(arr: readonly number[]) {
  let sum = 0,
    num;
  while ((num = arr.pop()) !== undefined) {
    // ~~~ 'pop' does not exist on type 'readonly number[]'
    sum += num;
  }
  return sum;
}
```

- readonly number[] / number[]
  - ë°°ì—´ì˜ ìš”ì†Œë¥¼ ì½ì„ ìˆ˜ ìˆì§€ë§Œ, ì“¸ ìˆ˜ëŠ” ì—†ë‹¤.
  - lengthë¥¼ ì½ì„ ìˆ˜ ìˆì§€ë§Œ, ë°”ê¿€ ìˆ˜ëŠ” ì—†ë‹¤(ë°°ì—´ì„ ë³€ê²½í•¨).
  - ë°°ì—´ì„ ë³€ê²½í•˜ëŠ” popì„ ë¹„ë¡¯í•œ ë‹¤ë¥¸ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•  ìˆ˜ ì—†ë‹¤.

```tsx
// number[]ë¥¼ readonly number[]ì— í• ë‹¹í•  ìˆ˜ ìˆì§€ë§Œ, ê·¸ ë°˜ëŒ€ëŠ” ë¶ˆê°€ëŠ¥í•˜ë‹¤.
const a: number[] = [1, 2, 3];
const b: readonly number[] = a;
const c: number[] = b;
// ~ Type 'readonly number[]' is 'readonly' and cannot be
//   assigned to the mutable type 'number[]'
```

```tsx
// ì›ë³¸ ë°°ì—´ì„ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤.
function arraySum(arr: readonly number[]) {
  let sum = 0;
  for (const num of arr) {
    sum += num;
  }
  return sum;
}
```

```tsx
function parseTaggedText(lines: string[]): string[][] {
  const paragraphs: string[][] = [];
  const currPara: string[] = [];

  const addParagraph = () => {
    if (currPara.length) {
      // currParaì˜ ë‚´ìš©ì´ ì‚½ì…ë˜ì§€ ì•Šê³  ë°°ì—´ì˜ ì°¸ì¡°ê°€ ì‚½ì…ë˜ì—ˆë‹¤.
      paragraphs.push(currPara);
      currPara.length = 0; // Clear the lines
    }
  };

  for (const line of lines) {
    if (!line) {
      addParagraph();
    } else {
      currPara.push(line);
    }
  }
  addParagraph();
  return paragraphs;
}
```

```tsx
function parseTaggedText(lines: string[]): string[][] {
  const currPara: readonly string[] = [];
  const paragraphs: string[][] = [];

  const addParagraph = () => {
    if (currPara.length) {
      paragraphs.push(
        currPara
        // ~~~~~~~~ Type 'readonly string[]' is 'readonly' and
        //          cannot be assigned to the mutable type 'string[]'
      );
      currPara.length = 0; // Clear lines
      // ~~~~~~ Cannot assign to 'length' because it is a read-only
      // property
    }
  };

  for (const line of lines) {
    if (!line) {
      addParagraph();
    } else {
      currPara.push(line);
      // ~~~~ Property 'push' does not exist on type 'readonly string[]'
    }
  }
  addParagraph();
  return paragraphs;
}
```

```tsx
let currPara: readonly string[] = [];
// ...
// ê°€ë¦¬í‚¤ëŠ” ë°°ì—´ì„ ììœ ë¡­ê²Œ ë³€ê²½í•  ìˆ˜ ìˆì§€ë§Œ, ë°°ì—´ ìì²´ëŠ” ë³€ê²½í•˜ì§€ ëª»í•œë‹¤.
currPara = [];
// ...
// pushì™€ ë‹¬ë¦¬ concatì€ ì›ë³¸ì„ ìˆ˜ì •í•˜ì§€ ì•Šê³  ìƒˆ ë°°ì—´ì„ ë°˜í™˜í•œë‹¤.
currPara = currPara.concat([line]);

// ì—¬ì „íˆ paragraphsì— ëŒ€í•œ ì˜¤ë¥˜ëŠ” ë‚¨ì•„ìˆë‹¤.

// 1. currParaì˜ ë³µì‚¬ë³¸ ë§Œë“¤ê¸°
paragraphs.push([...currPara]);

// 2. paragraphsë¥¼ readonly string[]ìœ¼ë¡œ ë³€ê²½í•˜ê¸°
const paragraphs: (readonly string[])[] = [];

// 3. ë°°ì—´ì˜ readonly ì†ì„±ì„ ì œê±°í•˜ê¸° ìœ„í•´ ë‹¨ì–¸ë¬¸ ì“°ê¸°
paragraphs.push(currPara as string[]);
```

```tsx
// readonlyëŠ” ì–•ê²Œ(shallow) ë™ì‘í•œë‹¤.
// ê°ì²´ì˜ readonly ë°°ì—´ì´ ìˆë‹¤ë©´, ê·¸ ê°ì²´ ìì²´ëŠ” readonlyê°€ ì•„ë‹ˆë‹¤.
const dates: readonly Date[] = [new Date()];
dates.push(new Date());
// ~~~~ Property 'push' does not exist on type 'readonly Date[]'
dates[0].setFullYear(2037); // OK
```

```tsx
interface Outer {
  inner: {
    x: number;
  };
}
const o: Readonly<Outer> = { inner: { x: 0 } };
o.inner = { x: 1 };
// ~~~~ Cannot assign to 'inner' because it is a read-only property
o.inner.x = 1; // OK

type T = Readonly<Outer>;
// Type T = {
//   readonly inner: {
//     x: number;
//   };
// }

// ê¹Šì€ readonlyë¥¼ ì‚¬ìš©í•˜ë ¤ë©´, ts-essentialsì— ìˆëŠ” DeepReadonly ì œë„ˆë¦­ì„ ì‚¬ìš©í•˜ì.
// https://github.com/ts-essentials/ts-essentials/tree/master/lib/deep-readonly
```

```tsx
// ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜ì— readonlyë¥¼ ì‚¬ìš©í•˜ë©´ ê°ì²´ì˜ ì†ì„±ì´ ë³€ê²½ë˜ëŠ” ê²ƒì„ ë°©ì§€í•  ìˆ˜ ìˆë‹¤.
let obj: { readonly [k: string]: number } = {};
// Or Readonly<{[k: string]: number}
obj.hi = 45;
//  ~~ Index signature in type ... only permits reading
obj = { ...obj, hi: 12 }; // OK
obj = { ...obj, bye: 34 }; // OK
```

## ìš”ì•½

- ë§Œì•½ í•¨ìˆ˜ê°€ ë§¤ê°œë³€ìˆ˜ë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ readonlyë¡œ ì„ ì–¸í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤. readonly ë§¤ê°œë³€ìˆ˜ëŠ” ì¸í„°í˜ì´ìŠ¤ë¥¼ ëª…í™•í•˜ê²Œ í•˜ë©°, ë§¤ê°œë³€ìˆ˜ê°€ ë³€ê²½ë˜ëŠ” ê²ƒì„ ë°©ì§€í•œë‹¤.
- readonlyë¥¼ ì‚¬ìš©í•˜ë©´ ë³€ê²½í•˜ë©´ì„œ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ë°©ì§€í•  ìˆ˜ ìˆê³ , ë³€ê²½ì´ ë°œìƒí•˜ëŠ” ì½”ë“œë„ ì‰½ê²Œ ì°¾ì„ ìˆ˜ ìˆë‹¤.
- constì™€ readonlyì˜ ì°¨ì´ë¥¼ ì´í•´í•´ì•¼ í•œë‹¤.
- readonlyëŠ” ì–•ê²Œ ë™ì‘í•œë‹¤ëŠ” ê²ƒì„ ëª…ì‹¬í•´ì•¼ í•œë‹¤.

# ì•„ì´í…œ 18 ë§¤í•‘ëœ íƒ€ì…ì„ ì‚¬ìš©í•˜ì—¬ ê°’ì„ ë™ê¸°í™”í•˜ê¸°

```tsx
interface ScatterProps {
  // The data
  xs: number[];
  ys: number[];

  // Display
  xRange: [number, number];
  yRange: [number, number];
  color: string;

  // Events
  onClick: (x: number, y: number, index: number) => void;
}

// ìµœì í™” 1
// ìƒˆë¡œìš´ ì†ì„±ì´ ì¶”ê°€ë˜ë©´ shouldUpdate í•¨ìˆ˜ëŠ” ê°’ì´ ë³€ê²½ë  ë•Œë§ˆë‹¤ ì°¨íŠ¸ë¥¼ ë‹¤ì‹œ ê·¸ë¦°ë‹¤.
// ì´ë ‡ê²Œ ì²˜ë¦¬í•˜ëŠ” ê²ƒì„ 'ë³´ìˆ˜ì (conservative) ì ‘ê·¼ë²•' ë˜ëŠ” 'ì‹¤íŒ¨ì— ë‹«íŒ(fail close) ì ‘ê·¼ë²•' ì´ë¼ê³  í•œë‹¤.
// ì°¨íŠ¸ê°€ ì •í™•í•˜ì§€ë§Œ ë„ˆë¬´ ìì£¼ ê·¸ë ¤ì§ˆ ê°€ëŠ¥ì„±ì´ ìˆë‹¤.
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  let k: keyof ScatterProps;
  for (k in oldProps) {
    if (oldProps[k] !== newProps[k]) {
      if (k !== 'onClick') return true;
    }
  }
  return false;
}

// ìµœì í™” 2
// ì°¨íŠ¸ë¥¼ ë¶ˆí•„ìš”í•˜ê²Œ ë‹¤ì‹œ ê·¸ë¦¬ëŠ” ë‹¨ì ì„ í•´ê²°í–ˆë‹¤.
// í•˜ì§€ë§Œ ì‹¤ì œë¡œ ì°¨íŠ¸ë¥¼ ë‹¤ì‹œ ê·¸ë ¤ì•¼ í•  ê²½ìš°ì— ëˆ„ë½ë˜ëŠ” ì¼ì´ ìƒê¸¸ ìˆ˜ ìˆë‹¤.
function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  return (
    oldProps.xs !== newProps.xs ||
    oldProps.ys !== newProps.ys ||
    oldProps.xRange !== newProps.xRange ||
    oldProps.yRange !== newProps.yRange ||
    oldProps.color !== newProps.color
    // (no check for onClick)
  );
}

// ë‘ ê°€ì§€ ìµœì í™” ë°©ë²• ëª¨ë‘ ì´ìƒì ì´ì§€ ì•Šë‹¤. ìƒˆë¡œìš´ ì†ì„±ì´ ì¶”ê°€ë  ë•Œ ì§ì ‘ shouldUpdateë¥¼ ê³ ì¹˜ë„ë¡ í•˜ëŠ” ê²Œ ë‚«ë‹¤.

interface ScatterProps {
  xs: number[];
  ys: number[];
  // ...
  onClick: (x: number, y: number, index: number) => void;

  // Note: if you add a property here, update shouldUpdate!
}

// ê·¸ëŸ¬ë‚˜ ì´ ë°©ë²• ì—­ì‹œ ìµœì„ ì´ ì•„ë‹ˆë©°, íƒ€ì… ì²´ì»¤ê°€ ëŒ€ì‹ í•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.

// íƒ€ì… ì²´ì»¤ê°€ ë™ì‘í•˜ë„ë¡ ê°œì„ í•œ ì½”ë“œ
// í•µì‹¬ì€ ë§¤í•‘ëœ íƒ€ì… ê°ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤.
const REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {
  xs: true,
  ys: true,
  xRange: true,
  yRange: true,
  color: true,
  onClick: false,
};

function shouldUpdate(oldProps: ScatterProps, newProps: ScatterProps) {
  let k: keyof ScatterProps;
  for (k in oldProps) {
    if (oldProps[k] !== newProps[k] && REQUIRES_UPDATE[k]) {
      return true;
    }
  }
  return false;
}

// ğŸ¤” ë‚˜ì¤‘ì— ScatterPropsì— ìƒˆë¡œìš´ ì†ì„±ì„ ì¶”ê°€í•œë‹¤ë©´?
interface ScatterProps {
  // ...
  onDoubleClick: () => void;
}

// âœ… ì˜¤ë¥˜ë¥¼ ì •í™•íˆ ì¡ì•„ë‚¸ë‹¤.
const REQUIRES_UPDATE: { [k in keyof ScatterProps]: boolean } = {
  //  ~~~~~~~~~~~~~~~ Property 'onDoubleClick' is missing in type
  // COMPRESS
  xs: true,
  ys: true,
  xRange: true,
  yRange: true,
  color: true,
  onClick: false,
  // END
};

// ë°°ì—´ì„ ì‚¬ìš©í–ˆë‹¤ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ ëœë‹¤.
const PROPS_REQUIRING_UPDATE: (keyof ScatterProps)[] = [
  'xs',
  'ys',
  // ...
];

// ë§¤í•‘ëœ íƒ€ì…ì€ í•œ ê°ì²´ê°€ ë˜ ë‹¤ë¥¸ ê°ì²´ì™€ ì •í™•íˆ ê°™ì€ ì†ì„±ì„ ê°€ì§€ê²Œ í•  ë•Œ ì´ìƒì ì´ë‹¤.
// ìœ„ ì˜ˆì œì²˜ëŸ¼ ë§¤í•‘ëœ íƒ€ì…ì„ ì‚¬ìš©í•´ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì½”ë“œì— ì œì•½ì„ ê°•ì œí•˜ë„ë¡ í•  ìˆ˜ ìˆë‹¤.
```

## ìš”ì•½

- ë§¤í•‘ëœ íƒ€ì…ì„ ì‚¬ìš©í•´ì„œ ê´€ë ¨ëœ ê°’ê³¼ íƒ€ì…ì„ ë™ê¸°í™”í•˜ë„ë¡ í•˜ì.
- ì¸í„°í˜ì´ìŠ¤ì— ìƒˆë¡œìš´ ì†ì„±ì„ ì¶”ê°€í•  ë•Œ, ì„ íƒì„ ê°•ì œí•˜ë„ë¡ ë§¤í•‘ëœ íƒ€ì…ì„ ê³ ë ¤í•˜ì.
