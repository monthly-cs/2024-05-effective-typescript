# 1주차 발표 정리

## 아이템 1. 타입스크립트와 자바스크립트의 관계 이해하기

>- 타입스크립트는 자바스크립트의 상위집합(superset)이다.  
>- 타입스크립트는 타입이 정의된 자바스크립트의 상위집합이다.

- 타입스크립트는 작성된 코드를 파싱하고 자바스크립트로 변환 가능. -> JS와 TS 두 언어 관계에 중요한 점
- 자바스크립트는 .js, 타입스크립트는 .ts 확장자를 사용.
  - 타입스크립트는 자바스크립트의 상위집합
- 자바스크립트는 타입스크립트로 마이그레이션하는 이점이 존재 한다.

- 타입스크립트의 컴파일러는 자바스크립트의 프로그램에도 유용하다.
- 타입시스템의 목표는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것.
  - 타입체크가 모든 오류를 찾아내지는 않는다. 
  - 오류가 발생하진 않지만 의도와 다르게 동작하는 코드가 있을 수 있기에 항상 의도를 분명하게 하는 것이 좋다.

- 타입스크립트의 타입 시스템은 자바스크립트의 런타임 동작을 모델링한다.

## 아이템2 타입스크립트 설정 이해하기

### - noImplicitAny
 - 변수들이 미리 정의된 타입을 가져야 하는지 여부를 제어한다.
 - 타입스크립트는 타입 정보를 가질 때 가장 효과적이기 때문에 되도록이면 `noImplicitAny`를 설정하는 것이 좋다.

### - StrictNullChecks
- `null`과 `undefined`가 모든 타입에서 허용되는지 확인하는 설정.
- `null`을 허용하려고 한다면, 의도를 명시적으로 드러냄으로써 오류를 고칠 수 있다.

>  **타입스크립트 설정은 커맨드 라인을 이용하기보다는 tsconfig.json을 사용하는 것이 좋다.**


## 아이템3 코드 생성과 타입이 관계없음을 이해하기

### 타입스크립트 컴파일러는 두가지 역할을 수행한다.

- 최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 **트랜스파일(transpile)** 한다.
- 코드의 타입 오류를 체크한다.

> **트랜스파일(transpile)**  
> 번역(translate)과 컴파일(compile)이 합쳐져 트랜스파일이란 신조어 발생. 소스코드를 동일한 동작을 하는 다른 형태의 소스코드(다른버전, 다른언어 등)로 변환하는 행위를 의미한다. 결과물이 여전히 컴파일 되어야 하는 소스코드이기 때문에 컴파일과는 구분해서 부른다.

### 타입스크립트의 컴파일은 타입체크와 독립적으로 동작한다.
- 그러한 이유로 타입 오류가 있는 코드도 컴파일이 가능하다.
- 타입 오류가 있을 때 컴파일 하지 않으려면, `tsconfig.json`에 `noEmitError`를 설정하거나 빌드 도구에 동일하게 적용하면 된다.


## 아이템3 코드 생성과 타입이 관계없음을 이해하기

### 타입스크립트 컴파일러는 두가지 역할을 수행한다.

- 최신 TS/JS를 브라우저에서 동작할 수 있도록 구버전의 JS로 **트랜스파일(transpile)** 한다.
- 코드의 타입 오류를 체크한다.

> **트랜스파일(transpile)**  
> 번역(translate)과 컴파일(compile)이 합쳐져 트랜스파일이란 신조어 발생. 소스코드를 동일한 동작을 하는 다른 형태의 소스코드(다른버전, 다른언어 등)로 변환하는 행위를 의미한다. 결과물이 여전히 컴파일 되어야 하는 소스코드이기 때문에 컴파일과는 구분해서 부른다.

### 타입스크립트의 컴파일은 타입체크와 독립적으로 동작한다.
- 그러한 이유로 타입 오류가 있는 코드도 컴파일이 가능하다.
- 타입 오류가 있을 때 컴파일 하지 않으려면, `tsconfig.json`에 `noEmitError`를 설정하거나 빌드 도구에 동일하게 적용하면 된다.

---
> 2024-05-08 아이템3 이어서

### 런타임 타입은 선언된 타입과 다를 수 있다.
- 타입스크립트에서는 런타임 타입과 선언된 타입이 맞지 않을 수 있다.
- 선언된 타입이 언제든지 달라질 수 있기때문에 조심.

### 타입스크립트 타입으로는 함수를 오버로드 할 수 없다.
- 함수 오버로드 기능을 지원하기는 하지만 온전히 타입 수준에서만 동작함.
- 하나의 함수에 대해 여러개의 선언문을 작성할 수 있지만 구현체는 하나 뿐.

### 타입스크립트 타입은 런타임 성능에 영항을 주지 않는다.
- 타입과 타입 연산자는 자바스크립트 변환 시점에 제거된다. 그렇기 때문에 런타임의 성능에 아무런 영향을 주지 않는다.

<br />

---

**요약**
- 타입스크립트의 타입은 런타임 동작이나 성능에 영향 x    
- 타입에 오류가 있더라도 컴파일은 가능.  
- 타입은 런타임에 사용 x.   
  - 런타임에 타입을 지정하기 위해선 태그된 유니온과 속성체크 방법 사용. 
  - 혹은 클래스 같이 타입과 런타임 값을 둘 다 제공하는 방법이 있다.


## 아이템4 구조적 타이핑에 익숙해지기

- 자바스크립트는 **덕 타이핑** 기반이다. 
- 타입스크립트는 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경 쓰지 않고 그대로 모델링 한다.


> **덕 타이핑(duck typing)**  
객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우 객체를 해당 타입에 속하는 것으로 간주하는 방식이다. 덕 테스트(The Duck Test)에서 유래되었는데, 다음과 같은 명제로 정의된다. "만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다."

```typescript
interface Vector 2D {
    x: number;
    y: number;
}

function calculateLength(v:Vector2D) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
}

interface NamedVector {
    name: string;
    x: number;
    y: number;
}

const v: NamedVetor = { x:3, y;4, name: 'zee'};
caluateLength(v);   //정상, 결과는 5
``` 


```typescript
interface Vector3D {
    x: number;
    y: number;
    z: number;
}

function normalize(v: Vector3D) {
    const length = calculateLength(v);

    return {
        x: v.x / length,
        y: v.y / length,
        z: v.z / length,
    };
}

normalize({x: 3, y:4, z:5})
{ x: 0.6, y: 0.8, z:1 }
```



## 아이템5 any 타입 지양하기

- 타입 스크립트의 타입 시스템은 점진적(gradual)이고 선택적(optional)이다.
- 코드에 타입을 조금씩 추가할 수 있기 때문에 점진적이며, 언제든지 타입 체커를 해제할 수 있기 때문에 선택적이다.
- 이러한 기능들의 핵심은 **any타입**이다.

---

- any 타입에는 타입 안전성이 없다.
- any는 함수 시그니처를 무시해 버린다.
  - 함수를 작성할 시엔 시그니처를 명시해야 한다. 
    - 호출하는 쪽은 약속된 타입의 입력을 제공하고, 함수는 약속된 타입의 출력을 반환한다.
    - 그러나 any 타입을 사용하면 이런 약속을 어길 수 있다.
  
- any 타입에는 언어 서비스가 적용되지 않는다. 
  - 타입스크립트의 언어 서비스는 자동완성 기능과 적절한 도움말을 제공한다.
  - 그러나 any 타입인 심벌을 사용하면 아무런 도움을 받지 못한다.

- 타입스크립트의 모토는 '확장 가능한 자바스크립트' 이다.
  - 그 중 확장에서 가장 중요한 부분 중 하나가 언어서비스이다.
  - 이를 제대로 활용해야 생산성을 끌어올릴 수 있다.

- any 타입은 코드 리팩터링 때 버그를 감춘다.
- any는 타입 설계를 감춰버린다.
  - any타입을 사용하면 타입 설계가 불분명해진다. 
- any는 타입시스템의 신뢰도를 떨어뜨린다.
  - 타입스크립트의 타입 체커를 신뢰할 수 없다면 큰 문제가 생기며 도입의 의미가 없어진다.


**요약**
 - any타입을 사용하면 타입 체커와 타입스크립트 언어서비스를 못 사용하게 된다.
 - any 타입은 진짜 문제점을 감추며, 개발 경험을 나쁘게 한다.
 - any는 타입 시스템의 신뢰도를 떨어뜨린다.
 - **any 쓰지말자.**