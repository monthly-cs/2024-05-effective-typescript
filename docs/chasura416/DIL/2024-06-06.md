# DIL: 이펙티브 타입스크립트

> 스터디: 월간 CS, https://github.com/monthly-cs/2024-05-effective-typescript  
> 작성일: 2024-06-06  
> 작성자: chasura416

---
<br />

# 5장 any 다루기

### 아이템 40. 함수 안으로 타입 단언문 감추기

외부로 드러난 타입 정의는 간단하지만 내부 로직이 복잡해서 안전한 타입으로 구현하기 어려운 경우가 많다. 함수의 모든 부분을 안전한 타입으로 구현하는 것이 이상적이지만, 불필요한 예외 상황까지 고려해 가면서 타입 정보를 힘들게 구성할 필요는 없다.

함수 내부에는 타입 단언을 사용하고 함수 외부로 드러나는 타입 정의를 정확히 명시하는 정도로 끝내는 게 낫다. 프로젝트 전반에 위험한 타입 단언문이 드러나 있는 것보다 제대로 타입이 정의된 함수 안으로 타입 단언문을 감추는 것이 더 좋은 설계이다.

함수 캐싱은 리액트 같은 프레임 워크에서 실행 시간이 오래 걸리는 함수 호출을 개선하는 일반적인 기법이다. 

`declare function cacheLast<T extends Function>(Fn: T): T;`

```TypeScript
declare function ShallowEqual(a: any , b: any): boolean;
function cacheLast<T extends Function>(Fn: T): T {
  let lastArgs: any[] | null = null;
  let lastResult: any;
  
  return function(...args: any[]) {
      // ~~~~~~~~~~~~~~~~~~~~~~~~~
      // '(...args: any[]) => any` 형식은 'T' 형식에 할당할 수 없습니다.
    if (!lastArgs || !shallowEqual(lastArgs, args)) {
      lastResult = fn(...args);
      lastArgs = args;
    }
    return lastResult;
  };
}
```

```TypeScript

```

<br />

> **요약**
- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다.
- 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수안으로 숨기도록 하자.


<br />

---
### 아이템 41. any의 진화를 이해하기

타입스크립트에서 일반적으로 변수의 타입은 변수를 선언 할 때 결정된다.  
그 후에 정제될 수 있지만, 새로운 값을 추가되도록 확장할 수는 없다. 

그러나 any 타입과 관련해서는 예외인 경우가 존재한다.


<br />

> **요약**
- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화할 수 있다. 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야 한다.
- any를 진홧시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.

<br />

---
### 아이템 42. 모르는 타입의 값에는 any 대신 unknown을 사용하기

unknown에는 함수의 반환값과 관련된 형태, 변수 선언과 관련된 형태, 단언문과 관련된 형태가 있다.  
그리고 유사하지만 조금 다른형태도 존재한다.

<br />

> **요약**
- unknown은 any 대신 사용할 수 있는 안전한 타입이다. 어떠한 값이 있지만 그 타입을 알지 못하는 경우일 때 사용한다.
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknown을 사용하면 된다.
- {}, object, unknown의 차이점을 이해해야 한다.



